{"ast":null,"code":"/**\n * @file postscribe\n * @description Asynchronously write javascript, even with document.write.\n * @version v2.0.8\n * @see {@link https://krux.github.io/postscribe}\n * @license MIT\n * @author Derek Brans\n * @copyright 2016 Krux Digital, Inc\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"postscribe\"] = factory();else root[\"postscribe\"] = factory();\n})(this, function () {\n  return /******/function (modules) {\n    // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId) {\n      /******/\n      /******/ // Check if module is in cache\n      /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;\n      /******/\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = installedModules[moduleId] = {\n        /******/exports: {},\n        /******/id: moduleId,\n        /******/loaded: false\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n      /******/\n      /******/ // Flag the module as loaded\n      /******/\n      module.loaded = true;\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"\";\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(0);\n    /******/\n  }\n  /************************************************************************/\n  /******/([/* 0 */\n  /***/function (module, exports, __webpack_require__) {\n    'use strict';\n\n    var _postscribe = __webpack_require__(1);\n    var _postscribe2 = _interopRequireDefault(_postscribe);\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        'default': obj\n      };\n    }\n    module.exports = _postscribe2['default'];\n\n    /***/\n  }, /* 1 */\n  /***/function (module, exports, __webpack_require__) {\n    'use strict';\n\n    exports.__esModule = true;\n    var _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    exports['default'] = postscribe;\n    var _writeStream = __webpack_require__(2);\n    var _writeStream2 = _interopRequireDefault(_writeStream);\n    var _utils = __webpack_require__(4);\n    var utils = _interopRequireWildcard(_utils);\n    function _interopRequireWildcard(obj) {\n      if (obj && obj.__esModule) {\n        return obj;\n      } else {\n        var newObj = {};\n        if (obj != null) {\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n          }\n        }\n        newObj['default'] = obj;\n        return newObj;\n      }\n    }\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        'default': obj\n      };\n    }\n\n    /**\n     * A function that intentionally does nothing.\n     */\n    function doNothing() {}\n\n    /**\n     * Available options and defaults.\n     *\n     * @type {Object}\n     */\n    var OPTIONS = {\n      /**\n       * Called when an async script has loaded.\n       */\n      afterAsync: doNothing,\n      /**\n       * Called immediately before removing from the write queue.\n       */\n      afterDequeue: doNothing,\n      /**\n       * Called sync after a stream's first thread release.\n       */\n      afterStreamStart: doNothing,\n      /**\n       * Called after writing buffered document.write calls.\n       */\n      afterWrite: doNothing,\n      /**\n       * Allows disabling the autoFix feature of prescribe\n       */\n      autoFix: true,\n      /**\n       * Called immediately before adding to the write queue.\n       */\n      beforeEnqueue: doNothing,\n      /**\n       * Called before writing a token.\n       *\n       * @param {Object} tok The token\n       */\n      beforeWriteToken: function beforeWriteToken(tok) {\n        return tok;\n      },\n      /**\n       * Called before writing buffered document.write calls.\n       *\n       * @param {String} str The string\n       */\n      beforeWrite: function beforeWrite(str) {\n        return str;\n      },\n      /**\n       * Called when evaluation is finished.\n       */\n      done: doNothing,\n      /**\n       * Called when a write results in an error.\n       *\n       * @param {Error} e The error\n       */\n      error: function error(e) {\n        throw new Error(e.msg);\n      },\n      /**\n       * Whether to let scripts w/ async attribute set fall out of the queue.\n       */\n      releaseAsync: false\n    };\n    var nextId = 0;\n    var queue = [];\n    var active = null;\n    function nextStream() {\n      var args = queue.shift();\n      if (args) {\n        var options = utils.last(args);\n        options.afterDequeue();\n        args.stream = runStream.apply(undefined, args);\n        options.afterStreamStart();\n      }\n    }\n    function runStream(el, html, options) {\n      active = new _writeStream2['default'](el, options);\n\n      // Identify this stream.\n      active.id = nextId++;\n      active.name = options.name || active.id;\n      postscribe.streams[active.name] = active;\n\n      // Override document.write.\n      var doc = el.ownerDocument;\n      var stash = {\n        close: doc.close,\n        open: doc.open,\n        write: doc.write,\n        writeln: doc.writeln\n      };\n      function _write(str) {\n        str = options.beforeWrite(str);\n        active.write(str);\n        options.afterWrite(str);\n      }\n      _extends(doc, {\n        close: doNothing,\n        open: doNothing,\n        write: function write() {\n          for (var _len = arguments.length, str = Array(_len), _key = 0; _key < _len; _key++) {\n            str[_key] = arguments[_key];\n          }\n          return _write(str.join(''));\n        },\n        writeln: function writeln() {\n          for (var _len2 = arguments.length, str = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            str[_key2] = arguments[_key2];\n          }\n          return _write(str.join('') + '\\n');\n        }\n      });\n\n      // Override window.onerror\n      var oldOnError = active.win.onerror || doNothing;\n\n      // This works together with the try/catch around WriteStream::insertScript\n      // In modern browsers, exceptions in tag scripts go directly to top level\n      active.win.onerror = function (msg, url, line) {\n        options.error({\n          msg: msg + ' - ' + url + ': ' + line\n        });\n        oldOnError.apply(active.win, [msg, url, line]);\n      };\n\n      // Write to the stream\n      active.write(html, function () {\n        // restore document.write\n        _extends(doc, stash);\n\n        // restore window.onerror\n        active.win.onerror = oldOnError;\n        options.done();\n        active = null;\n        nextStream();\n      });\n      return active;\n    }\n    function postscribe(el, html, options) {\n      if (utils.isFunction(options)) {\n        options = {\n          done: options\n        };\n      } else if (options === 'clear') {\n        queue = [];\n        active = null;\n        nextId = 0;\n        return;\n      }\n      options = utils.defaults(options, OPTIONS);\n\n      // id selector\n      if (/^#/.test(el)) {\n        el = window.document.getElementById(el.substr(1));\n      } else {\n        el = el.jquery ? el[0] : el;\n      }\n      var args = [el, html, options];\n      el.postscribe = {\n        cancel: function cancel() {\n          if (args.stream) {\n            args.stream.abort();\n          } else {\n            args[1] = doNothing;\n          }\n        }\n      };\n      options.beforeEnqueue(args);\n      queue.push(args);\n      if (!active) {\n        nextStream();\n      }\n      return el.postscribe;\n    }\n    _extends(postscribe, {\n      // Streams by name.\n      streams: {},\n      // Queue of streams.\n      queue: queue,\n      // Expose internal classes.\n      WriteStream: _writeStream2['default']\n    });\n\n    /***/\n  }, /* 2 */\n  /***/function (module, exports, __webpack_require__) {\n    'use strict';\n\n    exports.__esModule = true;\n    var _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    var _prescribe = __webpack_require__(3);\n    var _prescribe2 = _interopRequireDefault(_prescribe);\n    var _utils = __webpack_require__(4);\n    var utils = _interopRequireWildcard(_utils);\n    function _interopRequireWildcard(obj) {\n      if (obj && obj.__esModule) {\n        return obj;\n      } else {\n        var newObj = {};\n        if (obj != null) {\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n          }\n        }\n        newObj['default'] = obj;\n        return newObj;\n      }\n    }\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        'default': obj\n      };\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    /**\n     * Turn on to debug how each chunk affected the DOM.\n     * @type {boolean}\n     */\n    var DEBUG_CHUNK = false;\n\n    /**\n     * Prefix for data attributes on DOM elements.\n     * @type {string}\n     */\n    var BASEATTR = 'data-ps-';\n\n    /**\n     * ID for the style proxy\n     * @type {string}\n     */\n    var PROXY_STYLE = 'ps-style';\n\n    /**\n     * ID for the script proxy\n     * @type {string}\n     */\n    var PROXY_SCRIPT = 'ps-script';\n\n    /**\n     * Get data attributes\n     *\n     * @param {Object} el The DOM element.\n     * @param {String} name The attribute name.\n     * @returns {String}\n     */\n    function getData(el, name) {\n      var attr = BASEATTR + name;\n      var val = el.getAttribute(attr);\n\n      // IE 8 returns a number if it's a number\n      return !utils.existy(val) ? val : String(val);\n    }\n\n    /**\n     * Set data attributes\n     *\n     * @param {Object} el The DOM element.\n     * @param {String} name The attribute name.\n     * @param {null|*} value The attribute value.\n     */\n    function setData(el, name) {\n      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var attr = BASEATTR + name;\n      if (utils.existy(value) && value !== '') {\n        el.setAttribute(attr, value);\n      } else {\n        el.removeAttribute(attr);\n      }\n    }\n\n    /**\n     * Stream static html to an element, where \"static html\" denotes \"html\n     * without scripts\".\n     *\n     * This class maintains a *history of writes devoid of any attributes* or\n     * \"proxy history\".\n     *\n     * Injecting the proxy history into a temporary div has no side-effects,\n     * other than to create proxy elements for previously written elements.\n     *\n     * Given the `staticHtml` of a new write, a `tempDiv`'s innerHTML is set to\n     * `proxy_history + staticHtml`.\n     * The *structure* of `tempDiv`'s contents, (i.e., the placement of new nodes\n     * beside or inside of proxy elements), reflects the DOM structure that would\n     * have resulted if all writes had been squashed into a single write.\n     *\n     * For each descendent `node` of `tempDiv` whose parentNode is a *proxy*,\n     * `node` is appended to the corresponding *real* element within the DOM.\n     *\n     * Proxy elements are mapped to *actual* elements in the DOM by injecting a\n     * `data-id` attribute into each start tag in `staticHtml`.\n     *\n     */\n\n    var WriteStream = function () {\n      /**\n       * Constructor.\n       *\n       * @param {Object} root The root element\n       * @param {?Object} options The options\n       */\n      function WriteStream(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        _classCallCheck(this, WriteStream);\n        this.root = root;\n        this.options = options;\n        this.doc = root.ownerDocument;\n        this.win = this.doc.defaultView || this.doc.parentWindow;\n        this.parser = new _prescribe2['default']('', {\n          autoFix: options.autoFix\n        });\n\n        // Actual elements by id.\n        this.actuals = [root];\n\n        // Embodies the \"structure\" of what's been written so far,\n        // devoid of attributes.\n        this.proxyHistory = '';\n\n        // Create a proxy of the root element.\n        this.proxyRoot = this.doc.createElement(root.nodeName);\n        this.scriptStack = [];\n        this.writeQueue = [];\n        setData(this.proxyRoot, 'proxyof', 0);\n      }\n\n      /**\n       * Writes the given strings.\n       *\n       * @param {...String} str The strings to write\n       */\n\n      WriteStream.prototype.write = function write() {\n        var _writeQueue;\n        (_writeQueue = this.writeQueue).push.apply(_writeQueue, arguments);\n\n        // Process writes\n        // When new script gets pushed or pending this will stop\n        // because new writeQueue gets pushed\n        while (!this.deferredRemote && this.writeQueue.length) {\n          var arg = this.writeQueue.shift();\n          if (utils.isFunction(arg)) {\n            this._callFunction(arg);\n          } else {\n            this._writeImpl(arg);\n          }\n        }\n      };\n\n      /**\n       * Calls the given function.\n       *\n       * @param {Function} fn The function to call\n       * @private\n       */\n\n      WriteStream.prototype._callFunction = function _callFunction(fn) {\n        var tok = {\n          type: 'function',\n          value: fn.name || fn.toString()\n        };\n        this._onScriptStart(tok);\n        fn.call(this.win, this.doc);\n        this._onScriptDone(tok);\n      };\n\n      /**\n       * The write implementation\n       *\n       * @param {String} html The HTML to write.\n       * @private\n       */\n\n      WriteStream.prototype._writeImpl = function _writeImpl(html) {\n        this.parser.append(html);\n        var tok = void 0;\n        var script = void 0;\n        var style = void 0;\n        var tokens = [];\n\n        // stop if we see a script token\n        while ((tok = this.parser.readToken()) && !(script = utils.isScript(tok)) && !(style = utils.isStyle(tok))) {\n          tok = this.options.beforeWriteToken(tok);\n          if (tok) {\n            tokens.push(tok);\n          }\n        }\n        if (tokens.length > 0) {\n          this._writeStaticTokens(tokens);\n        }\n        if (script) {\n          this._handleScriptToken(tok);\n        }\n        if (style) {\n          this._handleStyleToken(tok);\n        }\n      };\n\n      /**\n       * Write contiguous non-script tokens (a chunk)\n       *\n       * @param {Array<Object>} tokens The tokens\n       * @returns {{tokens, raw, actual, proxy}|null}\n       * @private\n       */\n\n      WriteStream.prototype._writeStaticTokens = function _writeStaticTokens(tokens) {\n        var chunk = this._buildChunk(tokens);\n        if (!chunk.actual) {\n          // e.g., no tokens, or a noscript that got ignored\n          return null;\n        }\n        chunk.html = this.proxyHistory + chunk.actual;\n        this.proxyHistory += chunk.proxy;\n        this.proxyRoot.innerHTML = chunk.html;\n        if (DEBUG_CHUNK) {\n          chunk.proxyInnerHTML = this.proxyRoot.innerHTML;\n        }\n        this._walkChunk();\n        if (DEBUG_CHUNK) {\n          chunk.actualInnerHTML = this.root.innerHTML;\n        }\n        return chunk;\n      };\n\n      /**\n       * Build a chunk.\n       *\n       * @param {Array<Object>} tokens The tokens to use.\n       * @returns {{tokens: *, raw: string, actual: string, proxy: string}}\n       * @private\n       */\n\n      WriteStream.prototype._buildChunk = function _buildChunk(tokens) {\n        var nextId = this.actuals.length;\n\n        // The raw html of this chunk.\n        var raw = [];\n\n        // The html to create the nodes in the tokens (with id's injected).\n        var actual = [];\n\n        // Html that can later be used to proxy the nodes in the tokens.\n        var proxy = [];\n        var len = tokens.length;\n        for (var i = 0; i < len; i++) {\n          var tok = tokens[i];\n          var tokenRaw = tok.toString();\n          raw.push(tokenRaw);\n          if (tok.attrs) {\n            // tok.attrs <==> startTag or atomicTag or cursor\n            // Ignore noscript tags. They are atomic, so we don't have to worry about children.\n            if (!/^noscript$/i.test(tok.tagName)) {\n              var id = nextId++;\n\n              // Actual: inject id attribute: replace '>' at end of start tag with id attribute + '>'\n              actual.push(tokenRaw.replace(/(\\/?>)/, ' ' + BASEATTR + 'id=' + id + ' $1'));\n\n              // Don't proxy scripts: they have no bearing on DOM structure.\n              if (tok.attrs.id !== PROXY_SCRIPT && tok.attrs.id !== PROXY_STYLE) {\n                // Proxy: strip all attributes and inject proxyof attribute\n                proxy.push(\n                // ignore atomic tags (e.g., style): they have no \"structural\" effect\n                tok.type === 'atomicTag' ? '' : '<' + tok.tagName + ' ' + BASEATTR + 'proxyof=' + id + (tok.unary ? ' />' : '>'));\n              }\n            }\n          } else {\n            // Visit any other type of token\n            // Actual: append.\n            actual.push(tokenRaw);\n\n            // Proxy: append endTags. Ignore everything else.\n            proxy.push(tok.type === 'endTag' ? tokenRaw : '');\n          }\n        }\n        return {\n          tokens: tokens,\n          raw: raw.join(''),\n          actual: actual.join(''),\n          proxy: proxy.join('')\n        };\n      };\n\n      /**\n       * Walk the chunks.\n       *\n       * @private\n       */\n\n      WriteStream.prototype._walkChunk = function _walkChunk() {\n        var node = void 0;\n        var stack = [this.proxyRoot];\n\n        // use shift/unshift so that children are walked in document order\n        while (utils.existy(node = stack.shift())) {\n          var isElement = node.nodeType === 1;\n          var isProxy = isElement && getData(node, 'proxyof');\n\n          // Ignore proxies\n          if (!isProxy) {\n            if (isElement) {\n              // New actual element: register it and remove the the id attr.\n              this.actuals[getData(node, 'id')] = node;\n              setData(node, 'id');\n            }\n\n            // Is node's parent a proxy?\n            var parentIsProxyOf = node.parentNode && getData(node.parentNode, 'proxyof');\n            if (parentIsProxyOf) {\n              // Move node under actual parent.\n              this.actuals[parentIsProxyOf].appendChild(node);\n            }\n          }\n\n          // prepend childNodes to stack\n          stack.unshift.apply(stack, utils.toArray(node.childNodes));\n        }\n      };\n\n      /**\n       * Handles Script tokens\n       *\n       * @param {Object} tok The token\n       */\n\n      WriteStream.prototype._handleScriptToken = function _handleScriptToken(tok) {\n        var _this = this;\n        var remainder = this.parser.clear();\n        if (remainder) {\n          // Write remainder immediately behind this script.\n          this.writeQueue.unshift(remainder);\n        }\n        tok.src = tok.attrs.src || tok.attrs.SRC;\n        tok = this.options.beforeWriteToken(tok);\n        if (!tok) {\n          // User has removed this token\n          return;\n        }\n        if (tok.src && this.scriptStack.length) {\n          // Defer this script until scriptStack is empty.\n          // Assumption 1: This script will not start executing until\n          // scriptStack is empty.\n          this.deferredRemote = tok;\n        } else {\n          this._onScriptStart(tok);\n        }\n\n        // Put the script node in the DOM.\n        this._writeScriptToken(tok, function () {\n          _this._onScriptDone(tok);\n        });\n      };\n\n      /**\n       * Handles style tokens\n       *\n       * @param {Object} tok The token\n       */\n\n      WriteStream.prototype._handleStyleToken = function _handleStyleToken(tok) {\n        var remainder = this.parser.clear();\n        if (remainder) {\n          // Write remainder immediately behind this style.\n          this.writeQueue.unshift(remainder);\n        }\n        tok.type = tok.attrs.type || tok.attrs.TYPE || 'text/css';\n        tok = this.options.beforeWriteToken(tok);\n        if (tok) {\n          // Put the style node in the DOM.\n          this._writeStyleToken(tok);\n        }\n        if (remainder) {\n          this.write();\n        }\n      };\n\n      /**\n       * Build a style and insert it into the DOM.\n       *\n       * @param {Object} tok The token\n       */\n\n      WriteStream.prototype._writeStyleToken = function _writeStyleToken(tok) {\n        var el = this._buildStyle(tok);\n        this._insertCursor(el, PROXY_STYLE);\n\n        // Set content\n        if (tok.content) {\n          if (el.styleSheet && !el.sheet) {\n            el.styleSheet.cssText = tok.content;\n          } else {\n            el.appendChild(this.doc.createTextNode(tok.content));\n          }\n        }\n      };\n\n      /**\n       * Build a style element from an atomic style token.\n       *\n       * @param {Object} tok The token\n       * @returns {Element}\n       */\n\n      WriteStream.prototype._buildStyle = function _buildStyle(tok) {\n        var el = this.doc.createElement(tok.tagName);\n        el.setAttribute('type', tok.type);\n\n        // Set attributes\n        utils.eachKey(tok.attrs, function (name, value) {\n          el.setAttribute(name, value);\n        });\n        return el;\n      };\n\n      /**\n       * Append a span to the stream. That span will act as a cursor\n       * (i.e. insertion point) for the element.\n       *\n       * @param {Object} el The element\n       * @param {string} which The type of proxy element\n       */\n\n      WriteStream.prototype._insertCursor = function _insertCursor(el, which) {\n        this._writeImpl('<span id=\"' + which + '\"/>');\n        var cursor = this.doc.getElementById(which);\n        if (cursor) {\n          cursor.parentNode.replaceChild(el, cursor);\n        }\n      };\n\n      /**\n       * Called when a script is started.\n       *\n       * @param {Object} tok The token\n       * @private\n       */\n\n      WriteStream.prototype._onScriptStart = function _onScriptStart(tok) {\n        tok.outerWrites = this.writeQueue;\n        this.writeQueue = [];\n        this.scriptStack.unshift(tok);\n      };\n\n      /**\n       * Called when a script is done.\n       *\n       * @param {Object} tok The token\n       * @private\n       */\n\n      WriteStream.prototype._onScriptDone = function _onScriptDone(tok) {\n        // Pop script and check nesting.\n        if (tok !== this.scriptStack[0]) {\n          this.options.error({\n            msg: 'Bad script nesting or script finished twice'\n          });\n          return;\n        }\n        this.scriptStack.shift();\n\n        // Append outer writes to queue and process them.\n        this.write.apply(this, tok.outerWrites);\n\n        // Check for pending remote\n\n        // Assumption 2: if remote_script1 writes remote_script2 then\n        // the we notice remote_script1 finishes before remote_script2 starts.\n        // I think this is equivalent to assumption 1\n        if (!this.scriptStack.length && this.deferredRemote) {\n          this._onScriptStart(this.deferredRemote);\n          this.deferredRemote = null;\n        }\n      };\n\n      /**\n       * Build a script and insert it into the DOM.\n       * Done is called once script has executed.\n       *\n       * @param {Object} tok The token\n       * @param {Function} done The callback when complete\n       */\n\n      WriteStream.prototype._writeScriptToken = function _writeScriptToken(tok, done) {\n        var el = this._buildScript(tok);\n        var asyncRelease = this._shouldRelease(el);\n        var afterAsync = this.options.afterAsync;\n        if (tok.src) {\n          // Fix for attribute \"SRC\" (capitalized). IE does not recognize it.\n          el.src = tok.src;\n          this._scriptLoadHandler(el, !asyncRelease ? function () {\n            done();\n            afterAsync();\n          } : afterAsync);\n        }\n        try {\n          this._insertCursor(el, PROXY_SCRIPT);\n          if (!el.src || asyncRelease) {\n            done();\n          }\n        } catch (e) {\n          this.options.error(e);\n          done();\n        }\n      };\n\n      /**\n       * Build a script element from an atomic script token.\n       *\n       * @param {Object} tok The token\n       * @returns {Element}\n       */\n\n      WriteStream.prototype._buildScript = function _buildScript(tok) {\n        var el = this.doc.createElement(tok.tagName);\n\n        // Set attributes\n        utils.eachKey(tok.attrs, function (name, value) {\n          el.setAttribute(name, value);\n        });\n\n        // Set content\n        if (tok.content) {\n          el.text = tok.content;\n        }\n        return el;\n      };\n\n      /**\n       * Setup the script load handler on an element.\n       *\n       * @param {Object} el The element\n       * @param {Function} done The callback\n       * @private\n       */\n\n      WriteStream.prototype._scriptLoadHandler = function _scriptLoadHandler(el, done) {\n        function cleanup() {\n          el = el.onload = el.onreadystatechange = el.onerror = null;\n        }\n        var error = this.options.error;\n        function success() {\n          cleanup();\n          if (done != null) {\n            done();\n          }\n          done = null;\n        }\n        function failure(err) {\n          cleanup();\n          error(err);\n          if (done != null) {\n            done();\n          }\n          done = null;\n        }\n        function reattachEventListener(el, evt) {\n          var handler = el['on' + evt];\n          if (handler != null) {\n            el['_on' + evt] = handler;\n          }\n        }\n        reattachEventListener(el, 'load');\n        reattachEventListener(el, 'error');\n        _extends(el, {\n          onload: function onload() {\n            if (el._onload) {\n              try {\n                el._onload.apply(this, Array.prototype.slice.call(arguments, 0));\n              } catch (err) {\n                failure({\n                  msg: 'onload handler failed ' + err + ' @ ' + el.src\n                });\n              }\n            }\n            success();\n          },\n          onerror: function onerror() {\n            if (el._onerror) {\n              try {\n                el._onerror.apply(this, Array.prototype.slice.call(arguments, 0));\n              } catch (err) {\n                failure({\n                  msg: 'onerror handler failed ' + err + ' @ ' + el.src\n                });\n                return;\n              }\n            }\n            failure({\n              msg: 'remote script failed ' + el.src\n            });\n          },\n          onreadystatechange: function onreadystatechange() {\n            if (/^(loaded|complete)$/.test(el.readyState)) {\n              success();\n            }\n          }\n        });\n      };\n\n      /**\n       * Determines whether to release.\n       *\n       * @param {Object} el The element\n       * @returns {boolean}\n       * @private\n       */\n\n      WriteStream.prototype._shouldRelease = function _shouldRelease(el) {\n        var isScript = /^script$/i.test(el.nodeName);\n        return !isScript || !!(this.options.releaseAsync && el.src && el.hasAttribute('async'));\n      };\n      return WriteStream;\n    }();\n    exports['default'] = WriteStream;\n\n    /***/\n  }, /* 3 */\n  /***/function (module, exports, __webpack_require__) {\n    /**\n     * @file prescribe\n     * @description Tiny, forgiving HTML parser\n     * @version vundefined\n     * @see {@link https://github.com/krux/prescribe/}\n     * @license MIT\n     * @author Derek Brans\n     * @copyright 2016 Krux Digital, Inc\n     */\n    (function webpackUniversalModuleDefinition(root, factory) {\n      if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"Prescribe\"] = factory();else root[\"Prescribe\"] = factory();\n    })(this, function () {\n      return /******/function (modules) {\n        // webpackBootstrap\n        /******/ // The module cache\n        /******/\n        var installedModules = {};\n\n        /******/ // The require function\n        /******/\n        function __webpack_require__(moduleId) {\n          /******/ // Check if module is in cache\n          /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;\n\n          /******/ // Create a new module (and put it into the cache)\n          /******/\n          var module = installedModules[moduleId] = {\n            /******/exports: {},\n            /******/id: moduleId,\n            /******/loaded: false\n            /******/\n          };\n\n          /******/ // Execute the module function\n          /******/\n          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n          /******/ // Flag the module as loaded\n          /******/\n          module.loaded = true;\n\n          /******/ // Return the exports of the module\n          /******/\n          return module.exports;\n          /******/\n        }\n\n        /******/ // expose the modules object (__webpack_modules__)\n        /******/\n        __webpack_require__.m = modules;\n\n        /******/ // expose the module cache\n        /******/\n        __webpack_require__.c = installedModules;\n\n        /******/ // __webpack_public_path__\n        /******/\n        __webpack_require__.p = \"\";\n\n        /******/ // Load entry module and return exports\n        /******/\n        return __webpack_require__(0);\n        /******/\n      }\n      /************************************************************************/\n      /******/([/* 0 */\n      /***/function (module, exports, __webpack_require__) {\n        'use strict';\n\n        var _HtmlParser = __webpack_require__(1);\n        var _HtmlParser2 = _interopRequireDefault(_HtmlParser);\n        function _interopRequireDefault(obj) {\n          return obj && obj.__esModule ? obj : {\n            'default': obj\n          };\n        }\n        module.exports = _HtmlParser2['default'];\n\n        /***/\n      }, /* 1 */\n      /***/function (module, exports, __webpack_require__) {\n        'use strict';\n\n        exports.__esModule = true;\n        var _supports = __webpack_require__(2);\n        var supports = _interopRequireWildcard(_supports);\n        var _streamReaders = __webpack_require__(3);\n        var streamReaders = _interopRequireWildcard(_streamReaders);\n        var _fixedReadTokenFactory = __webpack_require__(6);\n        var _fixedReadTokenFactory2 = _interopRequireDefault(_fixedReadTokenFactory);\n        var _utils = __webpack_require__(5);\n        function _interopRequireDefault(obj) {\n          return obj && obj.__esModule ? obj : {\n            'default': obj\n          };\n        }\n        function _interopRequireWildcard(obj) {\n          if (obj && obj.__esModule) {\n            return obj;\n          } else {\n            var newObj = {};\n            if (obj != null) {\n              for (var key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n              }\n            }\n            newObj['default'] = obj;\n            return newObj;\n          }\n        }\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        /**\n         * Detection regular expressions.\n         *\n         * Order of detection matters: detection of one can only\n         * succeed if detection of previous didn't\n        \t\t * @type {Object}\n         */\n        var detect = {\n          comment: /^<!--/,\n          endTag: /^<\\//,\n          atomicTag: /^<\\s*(script|style|noscript|iframe|textarea)[\\s\\/>]/i,\n          startTag: /^</,\n          chars: /^[^<]/\n        };\n\n        /**\n         * HtmlParser provides the capability to parse HTML and return tokens\n         * representing the tags and content.\n         */\n\n        var HtmlParser = function () {\n          /**\n           * Constructor.\n           *\n           * @param {string} stream The initial parse stream contents.\n           * @param {Object} options The options\n           * @param {boolean} options.autoFix Set to true to automatically fix errors\n           */\n          function HtmlParser() {\n            var _this = this;\n            var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            _classCallCheck(this, HtmlParser);\n            this.stream = stream;\n            var fix = false;\n            var fixedTokenOptions = {};\n            for (var key in supports) {\n              if (supports.hasOwnProperty(key)) {\n                if (options.autoFix) {\n                  fixedTokenOptions[key + 'Fix'] = true; // !supports[key];\n                }\n                fix = fix || fixedTokenOptions[key + 'Fix'];\n              }\n            }\n            if (fix) {\n              this._readToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n                return _this._readTokenImpl();\n              });\n              this._peekToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n                return _this._peekTokenImpl();\n              });\n            } else {\n              this._readToken = this._readTokenImpl;\n              this._peekToken = this._peekTokenImpl;\n            }\n          }\n\n          /**\n           * Appends the given string to the parse stream.\n           *\n           * @param {string} str The string to append\n           */\n\n          HtmlParser.prototype.append = function append(str) {\n            this.stream += str;\n          };\n\n          /**\n           * Prepends the given string to the parse stream.\n           *\n           * @param {string} str The string to prepend\n           */\n\n          HtmlParser.prototype.prepend = function prepend(str) {\n            this.stream = str + this.stream;\n          };\n\n          /**\n           * The implementation of the token reading.\n           *\n           * @private\n           * @returns {?Token}\n           */\n\n          HtmlParser.prototype._readTokenImpl = function _readTokenImpl() {\n            var token = this._peekTokenImpl();\n            if (token) {\n              this.stream = this.stream.slice(token.length);\n              return token;\n            }\n          };\n\n          /**\n           * The implementation of token peeking.\n           *\n           * @returns {?Token}\n           */\n\n          HtmlParser.prototype._peekTokenImpl = function _peekTokenImpl() {\n            for (var type in detect) {\n              if (detect.hasOwnProperty(type)) {\n                if (detect[type].test(this.stream)) {\n                  var token = streamReaders[type](this.stream);\n                  if (token) {\n                    if (token.type === 'startTag' && /script|style/i.test(token.tagName)) {\n                      return null;\n                    } else {\n                      token.text = this.stream.substr(0, token.length);\n                      return token;\n                    }\n                  }\n                }\n              }\n            }\n          };\n\n          /**\n           * The public token peeking interface.  Delegates to the basic token peeking\n           * or a version that performs fixups depending on the `autoFix` setting in\n           * options.\n           *\n           * @returns {object}\n           */\n\n          HtmlParser.prototype.peekToken = function peekToken() {\n            return this._peekToken();\n          };\n\n          /**\n           * The public token reading interface.  Delegates to the basic token reading\n           * or a version that performs fixups depending on the `autoFix` setting in\n           * options.\n           *\n           * @returns {object}\n           */\n\n          HtmlParser.prototype.readToken = function readToken() {\n            return this._readToken();\n          };\n\n          /**\n           * Read tokens and hand to the given handlers.\n           *\n           * @param {Object} handlers The handlers to use for the different tokens.\n           */\n\n          HtmlParser.prototype.readTokens = function readTokens(handlers) {\n            var tok = void 0;\n            while (tok = this.readToken()) {\n              // continue until we get an explicit \"false\" return\n              if (handlers[tok.type] && handlers[tok.type](tok) === false) {\n                return;\n              }\n            }\n          };\n\n          /**\n           * Clears the parse stream.\n           *\n           * @returns {string} The contents of the parse stream before clearing.\n           */\n\n          HtmlParser.prototype.clear = function clear() {\n            var rest = this.stream;\n            this.stream = '';\n            return rest;\n          };\n\n          /**\n           * Returns the rest of the parse stream.\n           *\n           * @returns {string} The contents of the parse stream.\n           */\n\n          HtmlParser.prototype.rest = function rest() {\n            return this.stream;\n          };\n          return HtmlParser;\n        }();\n        exports['default'] = HtmlParser;\n        HtmlParser.tokenToString = function (tok) {\n          return tok.toString();\n        };\n        HtmlParser.escapeAttributes = function (attrs) {\n          var escapedAttrs = {};\n          for (var name in attrs) {\n            if (attrs.hasOwnProperty(name)) {\n              escapedAttrs[name] = (0, _utils.escapeQuotes)(attrs[name], null);\n            }\n          }\n          return escapedAttrs;\n        };\n        HtmlParser.supports = supports;\n        for (var key in supports) {\n          if (supports.hasOwnProperty(key)) {\n            HtmlParser.browserHasFlaw = HtmlParser.browserHasFlaw || !supports[key] && key;\n          }\n        }\n\n        /***/\n      }, /* 2 */\n      /***/function (module, exports) {\n        'use strict';\n\n        exports.__esModule = true;\n        var tagSoup = false;\n        var selfClose = false;\n        var work = window.document.createElement('div');\n        try {\n          var html = '<P><I></P></I>';\n          work.innerHTML = html;\n          exports.tagSoup = tagSoup = work.innerHTML !== html;\n        } catch (e) {\n          exports.tagSoup = tagSoup = false;\n        }\n        try {\n          work.innerHTML = '<P><i><P></P></i></P>';\n          exports.selfClose = selfClose = work.childNodes.length === 2;\n        } catch (e) {\n          exports.selfClose = selfClose = false;\n        }\n        work = null;\n        exports.tagSoup = tagSoup;\n        exports.selfClose = selfClose;\n\n        /***/\n      }, /* 3 */\n      /***/function (module, exports, __webpack_require__) {\n        'use strict';\n\n        exports.__esModule = true;\n        var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n          return typeof obj;\n        } : function (obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n        exports.comment = comment;\n        exports.chars = chars;\n        exports.startTag = startTag;\n        exports.atomicTag = atomicTag;\n        exports.endTag = endTag;\n        var _tokens = __webpack_require__(4);\n\n        /**\n         * Regular Expressions for parsing tags and attributes\n         *\n         * @type {Object}\n         */\n        var REGEXES = {\n          startTag: /^<([\\-A-Za-z0-9_]+)((?:\\s+[\\w\\-]+(?:\\s*=?\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n          endTag: /^<\\/([\\-A-Za-z0-9_]+)[^>]*>/,\n          attr: /(?:([\\-A-Za-z0-9_]+)\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))|(?:([\\-A-Za-z0-9_]+)(\\s|$)+)/g,\n          fillAttr: /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i\n        };\n\n        /**\n         * Reads a comment token\n         *\n         * @param {string} stream The input stream\n         * @returns {CommentToken}\n         */\n        function comment(stream) {\n          var index = stream.indexOf('-->');\n          if (index >= 0) {\n            return new _tokens.CommentToken(stream.substr(4, index - 1), index + 3);\n          }\n        }\n\n        /**\n         * Reads non-tag characters.\n         *\n         * @param {string} stream The input stream\n         * @returns {CharsToken}\n         */\n        function chars(stream) {\n          var index = stream.indexOf('<');\n          return new _tokens.CharsToken(index >= 0 ? index : stream.length);\n        }\n\n        /**\n         * Reads start tag token.\n         *\n         * @param {string} stream The input stream\n         * @returns {StartTagToken}\n         */\n        function startTag(stream) {\n          var endTagIndex = stream.indexOf('>');\n          if (endTagIndex !== -1) {\n            var match = stream.match(REGEXES.startTag);\n            if (match) {\n              var _ret = function () {\n                var attrs = {};\n                var booleanAttrs = {};\n                var rest = match[2];\n                match[2].replace(REGEXES.attr, function (match, name) {\n                  if (!(arguments[2] || arguments[3] || arguments[4] || arguments[5])) {\n                    attrs[name] = '';\n                  } else if (arguments[5]) {\n                    attrs[arguments[5]] = '';\n                    booleanAttrs[arguments[5]] = true;\n                  } else {\n                    attrs[name] = arguments[2] || arguments[3] || arguments[4] || REGEXES.fillAttr.test(name) && name || '';\n                  }\n                  rest = rest.replace(match, '');\n                });\n                return {\n                  v: new _tokens.StartTagToken(match[1], match[0].length, attrs, booleanAttrs, !!match[3], rest.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''))\n                };\n              }();\n              if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n            }\n          }\n        }\n\n        /**\n         * Reads atomic tag token.\n         *\n         * @param {string} stream The input stream\n         * @returns {AtomicTagToken}\n         */\n        function atomicTag(stream) {\n          var start = startTag(stream);\n          if (start) {\n            var rest = stream.slice(start.length);\n            // for optimization, we check first just for the end tag\n            if (rest.match(new RegExp('<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'))) {\n              // capturing the content is inefficient, so we do it inside the if\n              var match = rest.match(new RegExp('([\\\\s\\\\S]*?)<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'));\n              if (match) {\n                return new _tokens.AtomicTagToken(start.tagName, match[0].length + start.length, start.attrs, start.booleanAttrs, match[1]);\n              }\n            }\n          }\n        }\n\n        /**\n         * Reads an end tag token.\n         *\n         * @param {string} stream The input stream\n         * @returns {EndTagToken}\n         */\n        function endTag(stream) {\n          var match = stream.match(REGEXES.endTag);\n          if (match) {\n            return new _tokens.EndTagToken(match[1], match[0].length);\n          }\n        }\n\n        /***/\n      }, /* 4 */\n      /***/function (module, exports, __webpack_require__) {\n        'use strict';\n\n        exports.__esModule = true;\n        exports.EndTagToken = exports.AtomicTagToken = exports.StartTagToken = exports.TagToken = exports.CharsToken = exports.CommentToken = exports.Token = undefined;\n        var _utils = __webpack_require__(5);\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        /**\n         * Token is a base class for all token types parsed.  Note we don't actually\n         * use intheritance due to IE8's non-existent ES5 support.\n         */\n        var Token =\n        /**\n         * Constructor.\n         *\n         * @param {string} type The type of the Token.\n         * @param {Number} length The length of the Token text.\n         */\n        exports.Token = function Token(type, length) {\n          _classCallCheck(this, Token);\n          this.type = type;\n          this.length = length;\n          this.text = '';\n        };\n\n        /**\n         * CommentToken represents comment tags.\n         */\n\n        var CommentToken = exports.CommentToken = function () {\n          /**\n           * Constructor.\n           *\n           * @param {string} content The content of the comment\n           * @param {Number} length The length of the Token text.\n           */\n          function CommentToken(content, length) {\n            _classCallCheck(this, CommentToken);\n            this.type = 'comment';\n            this.length = length || (content ? content.length : 0);\n            this.text = '';\n            this.content = content;\n          }\n          CommentToken.prototype.toString = function toString() {\n            return '<!--' + this.content;\n          };\n          return CommentToken;\n        }();\n\n        /**\n         * CharsToken represents non-tag characters.\n         */\n\n        var CharsToken = exports.CharsToken = function () {\n          /**\n           * Constructor.\n           *\n           * @param {Number} length The length of the Token text.\n           */\n          function CharsToken(length) {\n            _classCallCheck(this, CharsToken);\n            this.type = 'chars';\n            this.length = length;\n            this.text = '';\n          }\n          CharsToken.prototype.toString = function toString() {\n            return this.text;\n          };\n          return CharsToken;\n        }();\n\n        /**\n         * TagToken is a base class for all tag-based Tokens.\n         */\n\n        var TagToken = exports.TagToken = function () {\n          /**\n           * Constructor.\n           *\n           * @param {string} type The type of the token.\n           * @param {string} tagName The tag name.\n           * @param {Number} length The length of the Token text.\n           * @param {Object} attrs The dictionary of attributes and values\n           * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n           *                              is a boolean attribute\n           */\n          function TagToken(type, tagName, length, attrs, booleanAttrs) {\n            _classCallCheck(this, TagToken);\n            this.type = type;\n            this.length = length;\n            this.text = '';\n            this.tagName = tagName;\n            this.attrs = attrs;\n            this.booleanAttrs = booleanAttrs;\n            this.unary = false;\n            this.html5Unary = false;\n          }\n\n          /**\n           * Formats the given token tag.\n           *\n           * @param {TagToken} tok The TagToken to format.\n           * @param {?string} [content=null] The content of the token.\n           * @returns {string} The formatted tag.\n           */\n\n          TagToken.formatTag = function formatTag(tok) {\n            var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var str = '<' + tok.tagName;\n            for (var key in tok.attrs) {\n              if (tok.attrs.hasOwnProperty(key)) {\n                str += ' ' + key;\n                var val = tok.attrs[key];\n                if (typeof tok.booleanAttrs === 'undefined' || typeof tok.booleanAttrs[key] === 'undefined') {\n                  str += '=\"' + (0, _utils.escapeQuotes)(val) + '\"';\n                }\n              }\n            }\n            if (tok.rest) {\n              str += ' ' + tok.rest;\n            }\n            if (tok.unary && !tok.html5Unary) {\n              str += '/>';\n            } else {\n              str += '>';\n            }\n            if (content !== undefined && content !== null) {\n              str += content + '</' + tok.tagName + '>';\n            }\n            return str;\n          };\n          return TagToken;\n        }();\n\n        /**\n         * StartTagToken represents a start token.\n         */\n\n        var StartTagToken = exports.StartTagToken = function () {\n          /**\n           * Constructor.\n           *\n           * @param {string} tagName The tag name.\n           * @param {Number} length The length of the Token text\n           * @param {Object} attrs The dictionary of attributes and values\n           * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n           *                              is a boolean attribute\n           * @param {boolean} unary True if the tag is a unary tag\n           * @param {string} rest The rest of the content.\n           */\n          function StartTagToken(tagName, length, attrs, booleanAttrs, unary, rest) {\n            _classCallCheck(this, StartTagToken);\n            this.type = 'startTag';\n            this.length = length;\n            this.text = '';\n            this.tagName = tagName;\n            this.attrs = attrs;\n            this.booleanAttrs = booleanAttrs;\n            this.html5Unary = false;\n            this.unary = unary;\n            this.rest = rest;\n          }\n          StartTagToken.prototype.toString = function toString() {\n            return TagToken.formatTag(this);\n          };\n          return StartTagToken;\n        }();\n\n        /**\n         * AtomicTagToken represents an atomic tag.\n         */\n\n        var AtomicTagToken = exports.AtomicTagToken = function () {\n          /**\n           * Constructor.\n           *\n           * @param {string} tagName The name of the tag.\n           * @param {Number} length The length of the tag text.\n           * @param {Object} attrs The attributes.\n           * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n           *                              is a boolean attribute\n           * @param {string} content The content of the tag.\n           */\n          function AtomicTagToken(tagName, length, attrs, booleanAttrs, content) {\n            _classCallCheck(this, AtomicTagToken);\n            this.type = 'atomicTag';\n            this.length = length;\n            this.text = '';\n            this.tagName = tagName;\n            this.attrs = attrs;\n            this.booleanAttrs = booleanAttrs;\n            this.unary = false;\n            this.html5Unary = false;\n            this.content = content;\n          }\n          AtomicTagToken.prototype.toString = function toString() {\n            return TagToken.formatTag(this, this.content);\n          };\n          return AtomicTagToken;\n        }();\n\n        /**\n         * EndTagToken represents an end tag.\n         */\n\n        var EndTagToken = exports.EndTagToken = function () {\n          /**\n           * Constructor.\n           *\n           * @param {string} tagName The name of the tag.\n           * @param {Number} length The length of the tag text.\n           */\n          function EndTagToken(tagName, length) {\n            _classCallCheck(this, EndTagToken);\n            this.type = 'endTag';\n            this.length = length;\n            this.text = '';\n            this.tagName = tagName;\n          }\n          EndTagToken.prototype.toString = function toString() {\n            return '</' + this.tagName + '>';\n          };\n          return EndTagToken;\n        }();\n\n        /***/\n      }, /* 5 */\n      /***/function (module, exports) {\n        'use strict';\n\n        exports.__esModule = true;\n        exports.escapeQuotes = escapeQuotes;\n\n        /**\n         * Escape quotes in the given value.\n         *\n         * @param {string} value The value to escape.\n         * @param {string} [defaultValue=''] The default value to return if value is falsy.\n         * @returns {string}\n         */\n        function escapeQuotes(value) {\n          var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n          // There's no lookback in JS, so /(^|[^\\\\])\"/ only matches the first of two `\"`s.\n          // Instead, just match anything before a double-quote and escape if it's not already escaped.\n          return !value ? defaultValue : value.replace(/([^\"]*)\"/g, function (_, prefix) {\n            return /\\\\/.test(prefix) ? prefix + '\"' : prefix + '\\\\\"';\n          });\n        }\n\n        /***/\n      }, /* 6 */\n      /***/function (module, exports) {\n        'use strict';\n\n        exports.__esModule = true;\n        exports['default'] = fixedReadTokenFactory;\n        /**\n         * Empty Elements - HTML 4.01\n         *\n         * @type {RegExp}\n         */\n        var EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i;\n\n        /**\n         * Elements that you can intentionally leave open (and which close themselves)\n         *\n         * @type {RegExp}\n         */\n        var CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i;\n\n        /**\n         * Corrects a token.\n         *\n         * @param {Token} tok The token to correct\n         * @returns {Token} The corrected token\n         */\n        function correct(tok) {\n          if (tok && tok.type === 'startTag') {\n            tok.unary = EMPTY.test(tok.tagName) || tok.unary;\n            tok.html5Unary = !/\\/>$/.test(tok.text);\n          }\n          return tok;\n        }\n\n        /**\n         * Peeks at the next token in the parser.\n         *\n         * @param {HtmlParser} parser The parser\n         * @param {Function} readTokenImpl The underlying readToken implementation\n         * @returns {Token} The next token\n         */\n        function peekToken(parser, readTokenImpl) {\n          var tmp = parser.stream;\n          var tok = correct(readTokenImpl());\n          parser.stream = tmp;\n          return tok;\n        }\n\n        /**\n         * Closes the last token.\n         *\n         * @param {HtmlParser} parser The parser\n         * @param {Array<Token>} stack The stack\n         */\n        function closeLast(parser, stack) {\n          var tok = stack.pop();\n\n          // prepend close tag to stream.\n          parser.prepend('</' + tok.tagName + '>');\n        }\n\n        /**\n         * Create a new token stack.\n         *\n         * @returns {Array<Token>}\n         */\n        function newStack() {\n          var stack = [];\n          stack.last = function () {\n            return this[this.length - 1];\n          };\n          stack.lastTagNameEq = function (tagName) {\n            var last = this.last();\n            return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase();\n          };\n          stack.containsTagName = function (tagName) {\n            for (var i = 0, tok; tok = this[i]; i++) {\n              if (tok.tagName === tagName) {\n                return true;\n              }\n            }\n            return false;\n          };\n          return stack;\n        }\n\n        /**\n         * Return a readToken implementation that fixes input.\n         *\n         * @param {HtmlParser} parser The parser\n         * @param {Object} options Options for fixing\n         * @param {boolean} options.tagSoupFix True to fix tag soup scenarios\n         * @param {boolean} options.selfCloseFix True to fix self-closing tags\n         * @param {Function} readTokenImpl The underlying readToken implementation\n         * @returns {Function}\n         */\n        function fixedReadTokenFactory(parser, options, readTokenImpl) {\n          var stack = newStack();\n          var handlers = {\n            startTag: function startTag(tok) {\n              var tagName = tok.tagName;\n              if (tagName.toUpperCase() === 'TR' && stack.lastTagNameEq('TABLE')) {\n                parser.prepend('<TBODY>');\n                prepareNextToken();\n              } else if (options.selfCloseFix && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) {\n                if (stack.lastTagNameEq(tagName)) {\n                  closeLast(parser, stack);\n                } else {\n                  parser.prepend('</' + tok.tagName + '>');\n                  prepareNextToken();\n                }\n              } else if (!tok.unary) {\n                stack.push(tok);\n              }\n            },\n            endTag: function endTag(tok) {\n              var last = stack.last();\n              if (last) {\n                if (options.tagSoupFix && !stack.lastTagNameEq(tok.tagName)) {\n                  // cleanup tag soup\n                  closeLast(parser, stack);\n                } else {\n                  stack.pop();\n                }\n              } else if (options.tagSoupFix) {\n                // cleanup tag soup part 2: skip this token\n                readTokenImpl();\n                prepareNextToken();\n              }\n            }\n          };\n          function prepareNextToken() {\n            var tok = peekToken(parser, readTokenImpl);\n            if (tok && handlers[tok.type]) {\n              handlers[tok.type](tok);\n            }\n          }\n          return function fixedReadToken() {\n            prepareNextToken();\n            return correct(readTokenImpl());\n          };\n        }\n\n        /***/\n      }\n      /******/]);\n    });\n    ;\n\n    /***/\n  }, /* 4 */\n  /***/function (module, exports) {\n    'use strict';\n\n    exports.__esModule = true;\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n    exports.existy = existy;\n    exports.isFunction = isFunction;\n    exports.each = each;\n    exports.eachKey = eachKey;\n    exports.defaults = defaults;\n    exports.toArray = toArray;\n    exports.last = last;\n    exports.isTag = isTag;\n    exports.isScript = isScript;\n    exports.isStyle = isStyle;\n    /**\n     * Determine if the thing is not undefined and not null.\n     *\n     * @param {*} thing The thing to test\n     * @returns {boolean} True if the thing is not undefined and not null.\n     */\n    function existy(thing) {\n      return thing !== void 0 && thing !== null;\n    }\n\n    /**\n     * Is this a function?\n     *\n     * @param {*} x The variable to test\n     * @returns {boolean} True if the variable is a function\n     */\n    function isFunction(x) {\n      return 'function' === typeof x;\n    }\n\n    /**\n     * Loop over each item in an array-like value.\n     *\n     * @param {Array<*>} arr The array to loop over\n     * @param {Function} fn The function to call\n     * @param {?Object} target The object to bind to the function\n     */\n    function each(arr, fn, target) {\n      var i = void 0;\n      var len = arr && arr.length || 0;\n      for (i = 0; i < len; i++) {\n        fn.call(target, arr[i], i);\n      }\n    }\n\n    /**\n     * Loop over each key/value pair in a hash.\n     *\n     * @param {Object} obj The object\n     * @param {Function} fn The function to call\n     * @param {?Object} target The object to bind to the function\n     */\n    function eachKey(obj, fn, target) {\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          fn.call(target, key, obj[key]);\n        }\n      }\n    }\n\n    /**\n     * Set default options where some option was not specified.\n     *\n     * @param {Object} options The destination\n     * @param {Object} _defaults The defaults\n     * @returns {Object}\n     */\n    function defaults(options, _defaults) {\n      options = options || {};\n      eachKey(_defaults, function (key, val) {\n        if (!existy(options[key])) {\n          options[key] = val;\n        }\n      });\n      return options;\n    }\n\n    /**\n     * Convert value (e.g., a NodeList) to an array.\n     *\n     * @param {*} obj The object\n     * @returns {Array<*>}\n     */\n    function toArray(obj) {\n      try {\n        return Array.prototype.slice.call(obj);\n      } catch (e) {\n        var _ret = function () {\n          var ret = [];\n          each(obj, function (val) {\n            ret.push(val);\n          });\n          return {\n            v: ret\n          };\n        }();\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n    }\n\n    /**\n     * Get the last item in an array\n     *\n     * @param {Array<*>} array The array\n     * @returns {*} The last item in the array\n     */\n    function last(array) {\n      return array[array.length - 1];\n    }\n\n    /**\n     * Test if token is a script tag.\n     *\n     * @param {Object} tok The token\n     * @param {String} tag The tag name\n     * @returns {boolean} True if the token is a script tag\n     */\n    function isTag(tok, tag) {\n      return !tok || !(tok.type === 'startTag' || tok.type === 'atomicTag') || !('tagName' in tok) ? !1 : !!~tok.tagName.toLowerCase().indexOf(tag);\n    }\n\n    /**\n     * Test if token is a script tag.\n     *\n     * @param {Object} tok The token\n     * @returns {boolean} True if the token is a script tag\n     */\n    function isScript(tok) {\n      return isTag(tok, 'script');\n    }\n\n    /**\n     * Test if token is a style tag.\n     *\n     * @param {Object} tok The token\n     * @returns {boolean} True if the token is a style tag\n     */\n    function isStyle(tok) {\n      return isTag(tok, 'style');\n    }\n\n    /***/\n  }\n  /******/]);\n});\n;","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","module","exports","define","amd","modules","installedModules","__webpack_require__","moduleId","loaded","m","utils","_interopRequireWildcard","_utils","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","OPTIONS","beforeEnqueue","doNothing","beforeWriteToken","tok","beforeWrite","str","done","error","e","releaseAsync","nextId","queue","active","nextStream","args","options","last","afterDequeue","stream","runStream","apply","undefined","afterStreamStart","el","html","id","name","postscribe","streams","doc","ownerDocument","stash","close","open","writeln","_write","write","afterWrite","_extends","_len","arguments","length","Array","_key","join","_len2","_key2","oldOnError","win","onerror","msg","url","line","isFunction","defaults","test","window","document","getElementById","substr","jquery","cancel","push","PROXY_SCRIPT","getData","setData","value","attr","BASEATTR","WriteStream","parser","_classCallCheck","_prescribe2","autoFix","actuals","proxyHistory","_writeQueue","writeQueue","_writeImpl","append","script","style","tokens","readToken","isScript","isStyle","_writeStaticTokens","chunk","_buildChunk","actual","proxy","proxyRoot","innerHTML","proxyInnerHTML","_walkChunk","raw","len","i","tokenRaw","attrs","tagName","replace","PROXY_STYLE","type","unary","node","stack","existy","shift","isElement","nodeType","isProxy","parentIsProxyOf","parentNode","appendChild","_this","remainder","clear","unshift","src","SRC","scriptStack","_onScriptStart","TYPE","_writeStyleToken","_buildStyle","_insertCursor","content","createElement","which","_onScriptDone","outerWrites","_writeScriptToken","_buildScript","asyncRelease","_shouldRelease","afterAsync","_scriptLoadHandler","eachKey","cleanup","onload","onreadystatechange","success","failure","err","handler","evt","reattachEventListener","_onload","slice","_onerror","c","_HtmlParser","_interopRequireDefault","instance","Constructor","TypeError","detect","comment","endTag","startTag","chars","HtmlParser","fix","fixedTokenOptions","supports","_readToken","_fixedReadTokenFactory2","_readTokenImpl","_peekToken","_peekTokenImpl","prepend","token","streamReaders","text","peekToken","handlers","rest","tokenToString","toString","escapeAttributes","escapedAttrs","escapeQuotes","tagSoup","selfClose","work","atomicTag","_tokens","REGEXES","fillAttr","index","indexOf","CommentToken","CharsToken","endTagIndex","match","_ret","booleanAttrs","v","StartTagToken","_typeof","start","RegExp","AtomicTagToken","EndTagToken","TagToken","Token","html5Unary","formatTag","val","prefix","fixedReadTokenFactory","EMPTY","CLOSESELF","correct","readTokenImpl","tmp","closeLast","pop","newStack","lastTagNameEq","toUpperCase","containsTagName","prepareNextToken","selfCloseFix","tagSoupFix","isTag","thing","toArray","ret","each","toLowerCase","tag"],"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap c9988e4825e1b6d62704","webpack:///src/main.js","webpack:///src/postscribe.js","webpack:///src/write-stream.js","webpack:///~/prescribe/dist/prescribe.js","webpack:///src/utils.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"postscribe\"] = factory();\n\telse\n\t\troot[\"postscribe\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c9988e4825e1b6d62704","import postscribe from './postscribe';\n\nmodule.exports = postscribe;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","import WriteStream from './write-stream';\nimport * as utils from './utils';\n\n/**\n * A function that intentionally does nothing.\n */\nfunction doNothing() {\n}\n\n/**\n * Available options and defaults.\n *\n * @type {Object}\n */\nconst OPTIONS = {\n  /**\n   * Called when an async script has loaded.\n   */\n  afterAsync: doNothing,\n\n  /**\n   * Called immediately before removing from the write queue.\n   */\n  afterDequeue: doNothing,\n\n  /**\n   * Called sync after a stream's first thread release.\n   */\n  afterStreamStart: doNothing,\n\n  /**\n   * Called after writing buffered document.write calls.\n   */\n  afterWrite: doNothing,\n\n  /**\n   * Allows disabling the autoFix feature of prescribe\n   */\n  autoFix: true,\n\n  /**\n   * Called immediately before adding to the write queue.\n   */\n  beforeEnqueue: doNothing,\n\n  /**\n   * Called before writing a token.\n   *\n   * @param {Object} tok The token\n   */\n  beforeWriteToken: tok => tok,\n\n  /**\n   * Called before writing buffered document.write calls.\n   *\n   * @param {String} str The string\n   */\n  beforeWrite: str => str,\n\n  /**\n   * Called when evaluation is finished.\n   */\n  done: doNothing,\n\n  /**\n   * Called when a write results in an error.\n   *\n   * @param {Error} e The error\n   */\n  error(e) { throw new Error(e.msg); },\n\n  /**\n   * Whether to let scripts w/ async attribute set fall out of the queue.\n   */\n  releaseAsync: false\n};\n\nlet nextId = 0;\nlet queue = [];\nlet active = null;\n\nfunction nextStream() {\n  const args = queue.shift();\n  if (args) {\n    const options = utils.last(args);\n\n    options.afterDequeue();\n    args.stream = runStream(...args);\n    options.afterStreamStart();\n  }\n}\n\nfunction runStream(el, html, options) {\n  active = new WriteStream(el, options);\n\n  // Identify this stream.\n  active.id = nextId++;\n  active.name = options.name || active.id;\n  postscribe.streams[active.name] = active;\n\n  // Override document.write.\n  const doc = el.ownerDocument;\n\n  const stash = {\n    close: doc.close,\n    open: doc.open,\n    write: doc.write,\n    writeln: doc.writeln\n  };\n\n  function write(str) {\n    str = options.beforeWrite(str);\n    active.write(str);\n    options.afterWrite(str);\n  }\n\n  Object.assign(doc, {\n    close: doNothing,\n    open: doNothing,\n    write: (...str) => write(str.join('')),\n    writeln: (...str) => write(str.join('') + '\\n')\n  });\n\n  // Override window.onerror\n  const oldOnError = active.win.onerror || doNothing;\n\n  // This works together with the try/catch around WriteStream::insertScript\n  // In modern browsers, exceptions in tag scripts go directly to top level\n  active.win.onerror = (msg, url, line) => {\n    options.error({msg: `${msg} - ${url}: ${line}`});\n    oldOnError.apply(active.win, [msg, url, line]);\n  };\n\n  // Write to the stream\n  active.write(html, () => {\n    // restore document.write\n    Object.assign(doc, stash);\n\n    // restore window.onerror\n    active.win.onerror = oldOnError;\n\n    options.done();\n    active = null;\n    nextStream();\n  });\n\n  return active;\n}\n\nexport default function postscribe(el, html, options) {\n  if (utils.isFunction(options)) {\n    options = {done: options};\n  } else if (options === 'clear') {\n    queue = [];\n    active = null;\n    nextId = 0;\n    return;\n  }\n\n  options = utils.defaults(options, OPTIONS);\n\n  // id selector\n  if ((/^#/).test(el)) {\n    el = window.document.getElementById(el.substr(1));\n  } else {\n    el = el.jquery ? el[0] : el;\n  }\n\n  const args = [el, html, options];\n\n  el.postscribe = {\n    cancel: () => {\n      if (args.stream) {\n        args.stream.abort();\n      } else {\n        args[1] = doNothing;\n      }\n    }\n  };\n\n  options.beforeEnqueue(args);\n  queue.push(args);\n\n  if (!active) {\n    nextStream();\n  }\n\n  return el.postscribe;\n}\n\nObject.assign(postscribe, {\n  // Streams by name.\n  streams: {},\n  // Queue of streams.\n  queue,\n  // Expose internal classes.\n  WriteStream\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/postscribe.js","import HtmlParser from 'prescribe';\nimport * as utils from './utils';\n\n/**\n * Turn on to debug how each chunk affected the DOM.\n * @type {boolean}\n */\nconst DEBUG_CHUNK = false;\n\n/**\n * Prefix for data attributes on DOM elements.\n * @type {string}\n */\nconst BASEATTR = 'data-ps-';\n\n/**\n * ID for the style proxy\n * @type {string}\n */\nconst PROXY_STYLE = 'ps-style';\n\n/**\n * ID for the script proxy\n * @type {string}\n */\nconst PROXY_SCRIPT = 'ps-script';\n\n/**\n * Get data attributes\n *\n * @param {Object} el The DOM element.\n * @param {String} name The attribute name.\n * @returns {String}\n */\nfunction getData(el, name) {\n  const attr = BASEATTR + name;\n\n  const val = el.getAttribute(attr);\n\n  // IE 8 returns a number if it's a number\n  return !utils.existy(val) ? val : String(val);\n}\n\n/**\n * Set data attributes\n *\n * @param {Object} el The DOM element.\n * @param {String} name The attribute name.\n * @param {null|*} value The attribute value.\n */\nfunction setData(el, name, value = null) {\n  const attr = BASEATTR + name;\n\n  if (utils.existy(value) && value !== '') {\n    el.setAttribute(attr, value);\n  } else {\n    el.removeAttribute(attr);\n  }\n}\n\n/**\n * Stream static html to an element, where \"static html\" denotes \"html\n * without scripts\".\n *\n * This class maintains a *history of writes devoid of any attributes* or\n * \"proxy history\".\n *\n * Injecting the proxy history into a temporary div has no side-effects,\n * other than to create proxy elements for previously written elements.\n *\n * Given the `staticHtml` of a new write, a `tempDiv`'s innerHTML is set to\n * `proxy_history + staticHtml`.\n * The *structure* of `tempDiv`'s contents, (i.e., the placement of new nodes\n * beside or inside of proxy elements), reflects the DOM structure that would\n * have resulted if all writes had been squashed into a single write.\n *\n * For each descendent `node` of `tempDiv` whose parentNode is a *proxy*,\n * `node` is appended to the corresponding *real* element within the DOM.\n *\n * Proxy elements are mapped to *actual* elements in the DOM by injecting a\n * `data-id` attribute into each start tag in `staticHtml`.\n *\n */\nexport default class WriteStream {\n  /**\n   * Constructor.\n   *\n   * @param {Object} root The root element\n   * @param {?Object} options The options\n   */\n  constructor(root, options = {}) {\n    this.root = root;\n    this.options = options;\n    this.doc = root.ownerDocument;\n    this.win = this.doc.defaultView || this.doc.parentWindow;\n    this.parser = new HtmlParser('', {autoFix: options.autoFix});\n\n    // Actual elements by id.\n    this.actuals = [root];\n\n    // Embodies the \"structure\" of what's been written so far,\n    // devoid of attributes.\n    this.proxyHistory = '';\n\n    // Create a proxy of the root element.\n    this.proxyRoot = this.doc.createElement(root.nodeName);\n\n    this.scriptStack = [];\n    this.writeQueue = [];\n\n    setData(this.proxyRoot, 'proxyof', 0);\n  }\n\n  /**\n   * Writes the given strings.\n   *\n   * @param {...String} str The strings to write\n   */\n  write(...str) {\n    this.writeQueue.push(...str);\n\n    // Process writes\n    // When new script gets pushed or pending this will stop\n    // because new writeQueue gets pushed\n    while (!this.deferredRemote && this.writeQueue.length) {\n      const arg = this.writeQueue.shift();\n\n      if (utils.isFunction(arg)) {\n        this._callFunction(arg);\n      } else {\n        this._writeImpl(arg);\n      }\n    }\n  }\n\n  /**\n   * Calls the given function.\n   *\n   * @param {Function} fn The function to call\n   * @private\n   */\n  _callFunction(fn) {\n    const tok = {type: 'function', value: fn.name || fn.toString()};\n    this._onScriptStart(tok);\n    fn.call(this.win, this.doc);\n    this._onScriptDone(tok);\n  }\n\n  /**\n   * The write implementation\n   *\n   * @param {String} html The HTML to write.\n   * @private\n   */\n  _writeImpl(html) {\n    this.parser.append(html);\n\n    let tok;\n    let script;\n    let style;\n    const tokens = [];\n\n    // stop if we see a script token\n    while ((tok = this.parser.readToken()) &&\n      !(script = utils.isScript(tok)) &&\n      !(style = utils.isStyle(tok))) {\n      tok = this.options.beforeWriteToken(tok);\n\n      if (tok) {\n        tokens.push(tok);\n      }\n    }\n\n    if (tokens.length > 0) {\n      this._writeStaticTokens(tokens);\n    }\n\n    if (script) {\n      this._handleScriptToken(tok);\n    }\n\n    if (style) {\n      this._handleStyleToken(tok);\n    }\n  }\n\n  /**\n   * Write contiguous non-script tokens (a chunk)\n   *\n   * @param {Array<Object>} tokens The tokens\n   * @returns {{tokens, raw, actual, proxy}|null}\n   * @private\n   */\n  _writeStaticTokens(tokens) {\n    const chunk = this._buildChunk(tokens);\n\n    if (!chunk.actual) {\n      // e.g., no tokens, or a noscript that got ignored\n      return null;\n    }\n\n    chunk.html = this.proxyHistory + chunk.actual;\n    this.proxyHistory += chunk.proxy;\n    this.proxyRoot.innerHTML = chunk.html;\n\n    if (DEBUG_CHUNK) {\n      chunk.proxyInnerHTML = this.proxyRoot.innerHTML;\n    }\n\n    this._walkChunk();\n\n    if (DEBUG_CHUNK) {\n      chunk.actualInnerHTML = this.root.innerHTML;\n    }\n\n    return chunk;\n  }\n\n  /**\n   * Build a chunk.\n   *\n   * @param {Array<Object>} tokens The tokens to use.\n   * @returns {{tokens: *, raw: string, actual: string, proxy: string}}\n   * @private\n   */\n  _buildChunk(tokens) {\n    let nextId = this.actuals.length;\n\n    // The raw html of this chunk.\n    const raw = [];\n\n    // The html to create the nodes in the tokens (with id's injected).\n    const actual = [];\n\n    // Html that can later be used to proxy the nodes in the tokens.\n    const proxy = [];\n\n    const len = tokens.length;\n    for (let i = 0; i < len; i++) {\n      const tok = tokens[i];\n      const tokenRaw = tok.toString();\n\n      raw.push(tokenRaw);\n\n      if (tok.attrs) { // tok.attrs <==> startTag or atomicTag or cursor\n        // Ignore noscript tags. They are atomic, so we don't have to worry about children.\n        if (!(/^noscript$/i).test(tok.tagName)) {\n          const id = nextId++;\n\n          // Actual: inject id attribute: replace '>' at end of start tag with id attribute + '>'\n          actual.push(tokenRaw.replace(/(\\/?>)/, ` ${BASEATTR}id=${id} $1`));\n\n          // Don't proxy scripts: they have no bearing on DOM structure.\n          if (tok.attrs.id !== PROXY_SCRIPT && tok.attrs.id !== PROXY_STYLE) {\n            // Proxy: strip all attributes and inject proxyof attribute\n            proxy.push(\n              // ignore atomic tags (e.g., style): they have no \"structural\" effect\n              tok.type === 'atomicTag' ? '' :\n              `<${tok.tagName} ${BASEATTR}proxyof=${id}` + (tok.unary ? ' />' : '>')\n            );\n          }\n        }\n      } else {\n        // Visit any other type of token\n        // Actual: append.\n        actual.push(tokenRaw);\n\n        // Proxy: append endTags. Ignore everything else.\n        proxy.push(tok.type === 'endTag' ? tokenRaw : '');\n      }\n    }\n\n    return {\n      tokens,\n      raw: raw.join(''),\n      actual: actual.join(''),\n      proxy: proxy.join('')\n    };\n  }\n\n  /**\n   * Walk the chunks.\n   *\n   * @private\n   */\n  _walkChunk() {\n    let node;\n    const stack = [this.proxyRoot];\n\n    // use shift/unshift so that children are walked in document order\n    while (utils.existy(node = stack.shift())) {\n      const isElement = node.nodeType === 1;\n      const isProxy = isElement && getData(node, 'proxyof');\n\n      // Ignore proxies\n      if (!isProxy) {\n        if (isElement) {\n          // New actual element: register it and remove the the id attr.\n          this.actuals[getData(node, 'id')] = node;\n          setData(node, 'id');\n        }\n\n        // Is node's parent a proxy?\n        const parentIsProxyOf = node.parentNode &&\n          getData(node.parentNode, 'proxyof');\n        if (parentIsProxyOf) {\n          // Move node under actual parent.\n          this.actuals[parentIsProxyOf].appendChild(node);\n        }\n      }\n\n      // prepend childNodes to stack\n      stack.unshift.apply(stack, utils.toArray(node.childNodes));\n    }\n  }\n\n  /**\n   * Handles Script tokens\n   *\n   * @param {Object} tok The token\n   */\n  _handleScriptToken(tok) {\n    const remainder = this.parser.clear();\n\n    if (remainder) {\n      // Write remainder immediately behind this script.\n      this.writeQueue.unshift(remainder);\n    }\n\n    tok.src = tok.attrs.src || tok.attrs.SRC;\n\n    tok = this.options.beforeWriteToken(tok);\n    if (!tok) {\n      // User has removed this token\n      return;\n    }\n\n    if (tok.src && this.scriptStack.length) {\n      // Defer this script until scriptStack is empty.\n      // Assumption 1: This script will not start executing until\n      // scriptStack is empty.\n      this.deferredRemote = tok;\n    } else {\n      this._onScriptStart(tok);\n    }\n\n    // Put the script node in the DOM.\n    this._writeScriptToken(tok, () => {\n      this._onScriptDone(tok);\n    });\n  }\n\n  /**\n   * Handles style tokens\n   *\n   * @param {Object} tok The token\n   */\n  _handleStyleToken(tok) {\n    const remainder = this.parser.clear();\n\n    if (remainder) {\n      // Write remainder immediately behind this style.\n      this.writeQueue.unshift(remainder);\n    }\n\n    tok.type = tok.attrs.type || tok.attrs.TYPE || 'text/css';\n\n    tok = this.options.beforeWriteToken(tok);\n\n    if (tok) {\n      // Put the style node in the DOM.\n      this._writeStyleToken(tok);\n    }\n\n    if (remainder) {\n      this.write();\n    }\n  }\n\n  /**\n   * Build a style and insert it into the DOM.\n   *\n   * @param {Object} tok The token\n   */\n  _writeStyleToken(tok) {\n    const el = this._buildStyle(tok);\n\n    this._insertCursor(el, PROXY_STYLE);\n\n    // Set content\n    if (tok.content) {\n      if (el.styleSheet && !el.sheet) {\n        el.styleSheet.cssText = tok.content;\n      } else {\n        el.appendChild(this.doc.createTextNode(tok.content));\n      }\n    }\n  }\n\n  /**\n   * Build a style element from an atomic style token.\n   *\n   * @param {Object} tok The token\n   * @returns {Element}\n   */\n  _buildStyle(tok) {\n    const el = this.doc.createElement(tok.tagName);\n\n    el.setAttribute('type', tok.type);\n\n    // Set attributes\n    utils.eachKey(tok.attrs, (name, value) => {\n      el.setAttribute(name, value);\n    });\n\n    return el;\n  }\n\n  /**\n   * Append a span to the stream. That span will act as a cursor\n   * (i.e. insertion point) for the element.\n   *\n   * @param {Object} el The element\n   * @param {string} which The type of proxy element\n   */\n  _insertCursor(el, which) {\n    this._writeImpl(`<span id=\"${which}\"/>`);\n\n    const cursor = this.doc.getElementById(which);\n\n    if (cursor) {\n      cursor.parentNode.replaceChild(el, cursor);\n    }\n  }\n\n  /**\n   * Called when a script is started.\n   *\n   * @param {Object} tok The token\n   * @private\n   */\n  _onScriptStart(tok) {\n    tok.outerWrites = this.writeQueue;\n    this.writeQueue = [];\n    this.scriptStack.unshift(tok);\n  }\n\n  /**\n   * Called when a script is done.\n   *\n   * @param {Object} tok The token\n   * @private\n   */\n  _onScriptDone(tok) {\n    // Pop script and check nesting.\n    if (tok !== this.scriptStack[0]) {\n      this.options.error({msg: 'Bad script nesting or script finished twice'});\n      return;\n    }\n\n    this.scriptStack.shift();\n\n    // Append outer writes to queue and process them.\n    this.write.apply(this, tok.outerWrites);\n\n    // Check for pending remote\n\n    // Assumption 2: if remote_script1 writes remote_script2 then\n    // the we notice remote_script1 finishes before remote_script2 starts.\n    // I think this is equivalent to assumption 1\n    if (!this.scriptStack.length && this.deferredRemote) {\n      this._onScriptStart(this.deferredRemote);\n      this.deferredRemote = null;\n    }\n  }\n\n  /**\n   * Build a script and insert it into the DOM.\n   * Done is called once script has executed.\n   *\n   * @param {Object} tok The token\n   * @param {Function} done The callback when complete\n   */\n  _writeScriptToken(tok, done) {\n    const el = this._buildScript(tok);\n    const asyncRelease = this._shouldRelease(el);\n    const afterAsync = this.options.afterAsync;\n\n    if (tok.src) {\n      // Fix for attribute \"SRC\" (capitalized). IE does not recognize it.\n      el.src = tok.src;\n      this._scriptLoadHandler(el, !asyncRelease ? () => {\n        done();\n        afterAsync();\n      } : afterAsync);\n    }\n\n    try {\n      this._insertCursor(el, PROXY_SCRIPT);\n      if (!el.src || asyncRelease) {\n        done();\n      }\n    } catch (e) {\n      this.options.error(e);\n      done();\n    }\n  }\n\n  /**\n   * Build a script element from an atomic script token.\n   *\n   * @param {Object} tok The token\n   * @returns {Element}\n   */\n  _buildScript(tok) {\n    const el = this.doc.createElement(tok.tagName);\n\n    // Set attributes\n    utils.eachKey(tok.attrs, (name, value) => {\n      el.setAttribute(name, value);\n    });\n\n    // Set content\n    if (tok.content) {\n      el.text = tok.content;\n    }\n\n    return el;\n  }\n\n  /**\n   * Setup the script load handler on an element.\n   *\n   * @param {Object} el The element\n   * @param {Function} done The callback\n   * @private\n   */\n  _scriptLoadHandler(el, done) {\n    function cleanup() {\n      el = el.onload = el.onreadystatechange = el.onerror = null;\n    }\n\n    const error = this.options.error;\n\n    function success() {\n      cleanup();\n      if (done != null) {\n        done();\n      }\n      done = null;\n    }\n\n    function failure(err) {\n      cleanup();\n      error(err);\n      if (done != null) {\n        done();\n      }\n      done = null;\n    }\n\n    function reattachEventListener(el, evt) {\n      const handler = el[`on${evt}`];\n      if (handler != null) {\n        el[`_on${evt}`] = handler;\n      }\n    }\n\n    reattachEventListener(el, 'load');\n    reattachEventListener(el, 'error');\n\n    Object.assign(el, {\n      onload() {\n        if (el._onload) {\n          try {\n            el._onload.apply(this, Array.prototype.slice.call(arguments, 0));\n          } catch (err) {\n            failure({msg: `onload handler failed ${err} @ ${el.src}`});\n          }\n        }\n        success();\n      },\n\n      onerror() {\n        if (el._onerror) {\n          try {\n            el._onerror.apply(this, Array.prototype.slice.call(arguments, 0));\n          } catch (err) {\n            failure({msg: `onerror handler failed ${err} @ ${el.src}`});\n            return;\n          }\n        }\n        failure({msg: `remote script failed ${el.src}`});\n      },\n\n      onreadystatechange() {\n        if (/^(loaded|complete)$/.test(el.readyState)) {\n          success();\n        }\n      }\n    });\n  }\n\n  /**\n   * Determines whether to release.\n   *\n   * @param {Object} el The element\n   * @returns {boolean}\n   * @private\n   */\n  _shouldRelease(el) {\n    const isScript = (/^script$/i).test(el.nodeName);\n    return !isScript || !!(this.options.releaseAsync && el.src && el.hasAttribute('async'));\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/write-stream.js","/**\n * @file prescribe\n * @description Tiny, forgiving HTML parser\n * @version vundefined\n * @see {@link https://github.com/krux/prescribe/}\n * @license MIT\n * @author Derek Brans\n * @copyright 2016 Krux Digital, Inc\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Prescribe\"] = factory();\n\telse\n\t\troot[\"Prescribe\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _HtmlParser = __webpack_require__(1);\n\n\tvar _HtmlParser2 = _interopRequireDefault(_HtmlParser);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tmodule.exports = _HtmlParser2['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _supports = __webpack_require__(2);\n\n\tvar supports = _interopRequireWildcard(_supports);\n\n\tvar _streamReaders = __webpack_require__(3);\n\n\tvar streamReaders = _interopRequireWildcard(_streamReaders);\n\n\tvar _fixedReadTokenFactory = __webpack_require__(6);\n\n\tvar _fixedReadTokenFactory2 = _interopRequireDefault(_fixedReadTokenFactory);\n\n\tvar _utils = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/**\n\t * Detection regular expressions.\n\t *\n\t * Order of detection matters: detection of one can only\n\t * succeed if detection of previous didn't\n\n\t * @type {Object}\n\t */\n\tvar detect = {\n\t  comment: /^<!--/,\n\t  endTag: /^<\\//,\n\t  atomicTag: /^<\\s*(script|style|noscript|iframe|textarea)[\\s\\/>]/i,\n\t  startTag: /^</,\n\t  chars: /^[^<]/\n\t};\n\n\t/**\n\t * HtmlParser provides the capability to parse HTML and return tokens\n\t * representing the tags and content.\n\t */\n\n\tvar HtmlParser = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} stream The initial parse stream contents.\n\t   * @param {Object} options The options\n\t   * @param {boolean} options.autoFix Set to true to automatically fix errors\n\t   */\n\t  function HtmlParser() {\n\t    var _this = this;\n\n\t    var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t    _classCallCheck(this, HtmlParser);\n\n\t    this.stream = stream;\n\n\t    var fix = false;\n\t    var fixedTokenOptions = {};\n\n\t    for (var key in supports) {\n\t      if (supports.hasOwnProperty(key)) {\n\t        if (options.autoFix) {\n\t          fixedTokenOptions[key + 'Fix'] = true; // !supports[key];\n\t        }\n\t        fix = fix || fixedTokenOptions[key + 'Fix'];\n\t      }\n\t    }\n\n\t    if (fix) {\n\t      this._readToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n\t        return _this._readTokenImpl();\n\t      });\n\t      this._peekToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n\t        return _this._peekTokenImpl();\n\t      });\n\t    } else {\n\t      this._readToken = this._readTokenImpl;\n\t      this._peekToken = this._peekTokenImpl;\n\t    }\n\t  }\n\n\t  /**\n\t   * Appends the given string to the parse stream.\n\t   *\n\t   * @param {string} str The string to append\n\t   */\n\n\n\t  HtmlParser.prototype.append = function append(str) {\n\t    this.stream += str;\n\t  };\n\n\t  /**\n\t   * Prepends the given string to the parse stream.\n\t   *\n\t   * @param {string} str The string to prepend\n\t   */\n\n\n\t  HtmlParser.prototype.prepend = function prepend(str) {\n\t    this.stream = str + this.stream;\n\t  };\n\n\t  /**\n\t   * The implementation of the token reading.\n\t   *\n\t   * @private\n\t   * @returns {?Token}\n\t   */\n\n\n\t  HtmlParser.prototype._readTokenImpl = function _readTokenImpl() {\n\t    var token = this._peekTokenImpl();\n\t    if (token) {\n\t      this.stream = this.stream.slice(token.length);\n\t      return token;\n\t    }\n\t  };\n\n\t  /**\n\t   * The implementation of token peeking.\n\t   *\n\t   * @returns {?Token}\n\t   */\n\n\n\t  HtmlParser.prototype._peekTokenImpl = function _peekTokenImpl() {\n\t    for (var type in detect) {\n\t      if (detect.hasOwnProperty(type)) {\n\t        if (detect[type].test(this.stream)) {\n\t          var token = streamReaders[type](this.stream);\n\n\t          if (token) {\n\t            if (token.type === 'startTag' && /script|style/i.test(token.tagName)) {\n\t              return null;\n\t            } else {\n\t              token.text = this.stream.substr(0, token.length);\n\t              return token;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  /**\n\t   * The public token peeking interface.  Delegates to the basic token peeking\n\t   * or a version that performs fixups depending on the `autoFix` setting in\n\t   * options.\n\t   *\n\t   * @returns {object}\n\t   */\n\n\n\t  HtmlParser.prototype.peekToken = function peekToken() {\n\t    return this._peekToken();\n\t  };\n\n\t  /**\n\t   * The public token reading interface.  Delegates to the basic token reading\n\t   * or a version that performs fixups depending on the `autoFix` setting in\n\t   * options.\n\t   *\n\t   * @returns {object}\n\t   */\n\n\n\t  HtmlParser.prototype.readToken = function readToken() {\n\t    return this._readToken();\n\t  };\n\n\t  /**\n\t   * Read tokens and hand to the given handlers.\n\t   *\n\t   * @param {Object} handlers The handlers to use for the different tokens.\n\t   */\n\n\n\t  HtmlParser.prototype.readTokens = function readTokens(handlers) {\n\t    var tok = void 0;\n\t    while (tok = this.readToken()) {\n\t      // continue until we get an explicit \"false\" return\n\t      if (handlers[tok.type] && handlers[tok.type](tok) === false) {\n\t        return;\n\t      }\n\t    }\n\t  };\n\n\t  /**\n\t   * Clears the parse stream.\n\t   *\n\t   * @returns {string} The contents of the parse stream before clearing.\n\t   */\n\n\n\t  HtmlParser.prototype.clear = function clear() {\n\t    var rest = this.stream;\n\t    this.stream = '';\n\t    return rest;\n\t  };\n\n\t  /**\n\t   * Returns the rest of the parse stream.\n\t   *\n\t   * @returns {string} The contents of the parse stream.\n\t   */\n\n\n\t  HtmlParser.prototype.rest = function rest() {\n\t    return this.stream;\n\t  };\n\n\t  return HtmlParser;\n\t}();\n\n\texports['default'] = HtmlParser;\n\n\n\tHtmlParser.tokenToString = function (tok) {\n\t  return tok.toString();\n\t};\n\n\tHtmlParser.escapeAttributes = function (attrs) {\n\t  var escapedAttrs = {};\n\n\t  for (var name in attrs) {\n\t    if (attrs.hasOwnProperty(name)) {\n\t      escapedAttrs[name] = (0, _utils.escapeQuotes)(attrs[name], null);\n\t    }\n\t  }\n\n\t  return escapedAttrs;\n\t};\n\n\tHtmlParser.supports = supports;\n\n\tfor (var key in supports) {\n\t  if (supports.hasOwnProperty(key)) {\n\t    HtmlParser.browserHasFlaw = HtmlParser.browserHasFlaw || !supports[key] && key;\n\t  }\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\tvar tagSoup = false;\n\tvar selfClose = false;\n\n\tvar work = window.document.createElement('div');\n\n\ttry {\n\t  var html = '<P><I></P></I>';\n\t  work.innerHTML = html;\n\t  exports.tagSoup = tagSoup = work.innerHTML !== html;\n\t} catch (e) {\n\t  exports.tagSoup = tagSoup = false;\n\t}\n\n\ttry {\n\t  work.innerHTML = '<P><i><P></P></i></P>';\n\t  exports.selfClose = selfClose = work.childNodes.length === 2;\n\t} catch (e) {\n\t  exports.selfClose = selfClose = false;\n\t}\n\n\twork = null;\n\n\texports.tagSoup = tagSoup;\n\texports.selfClose = selfClose;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\texports.comment = comment;\n\texports.chars = chars;\n\texports.startTag = startTag;\n\texports.atomicTag = atomicTag;\n\texports.endTag = endTag;\n\n\tvar _tokens = __webpack_require__(4);\n\n\t/**\n\t * Regular Expressions for parsing tags and attributes\n\t *\n\t * @type {Object}\n\t */\n\tvar REGEXES = {\n\t  startTag: /^<([\\-A-Za-z0-9_]+)((?:\\s+[\\w\\-]+(?:\\s*=?\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n\t  endTag: /^<\\/([\\-A-Za-z0-9_]+)[^>]*>/,\n\t  attr: /(?:([\\-A-Za-z0-9_]+)\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))|(?:([\\-A-Za-z0-9_]+)(\\s|$)+)/g,\n\t  fillAttr: /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i\n\t};\n\n\t/**\n\t * Reads a comment token\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {CommentToken}\n\t */\n\tfunction comment(stream) {\n\t  var index = stream.indexOf('-->');\n\t  if (index >= 0) {\n\t    return new _tokens.CommentToken(stream.substr(4, index - 1), index + 3);\n\t  }\n\t}\n\n\t/**\n\t * Reads non-tag characters.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {CharsToken}\n\t */\n\tfunction chars(stream) {\n\t  var index = stream.indexOf('<');\n\t  return new _tokens.CharsToken(index >= 0 ? index : stream.length);\n\t}\n\n\t/**\n\t * Reads start tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {StartTagToken}\n\t */\n\tfunction startTag(stream) {\n\t  var endTagIndex = stream.indexOf('>');\n\t  if (endTagIndex !== -1) {\n\t    var match = stream.match(REGEXES.startTag);\n\t    if (match) {\n\t      var _ret = function () {\n\t        var attrs = {};\n\t        var booleanAttrs = {};\n\t        var rest = match[2];\n\n\t        match[2].replace(REGEXES.attr, function (match, name) {\n\t          if (!(arguments[2] || arguments[3] || arguments[4] || arguments[5])) {\n\t            attrs[name] = '';\n\t          } else if (arguments[5]) {\n\t            attrs[arguments[5]] = '';\n\t            booleanAttrs[arguments[5]] = true;\n\t          } else {\n\t            attrs[name] = arguments[2] || arguments[3] || arguments[4] || REGEXES.fillAttr.test(name) && name || '';\n\t          }\n\n\t          rest = rest.replace(match, '');\n\t        });\n\n\t        return {\n\t          v: new _tokens.StartTagToken(match[1], match[0].length, attrs, booleanAttrs, !!match[3], rest.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''))\n\t        };\n\t      }();\n\n\t      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Reads atomic tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {AtomicTagToken}\n\t */\n\tfunction atomicTag(stream) {\n\t  var start = startTag(stream);\n\t  if (start) {\n\t    var rest = stream.slice(start.length);\n\t    // for optimization, we check first just for the end tag\n\t    if (rest.match(new RegExp('<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'))) {\n\t      // capturing the content is inefficient, so we do it inside the if\n\t      var match = rest.match(new RegExp('([\\\\s\\\\S]*?)<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'));\n\t      if (match) {\n\t        return new _tokens.AtomicTagToken(start.tagName, match[0].length + start.length, start.attrs, start.booleanAttrs, match[1]);\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Reads an end tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {EndTagToken}\n\t */\n\tfunction endTag(stream) {\n\t  var match = stream.match(REGEXES.endTag);\n\t  if (match) {\n\t    return new _tokens.EndTagToken(match[1], match[0].length);\n\t  }\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.EndTagToken = exports.AtomicTagToken = exports.StartTagToken = exports.TagToken = exports.CharsToken = exports.CommentToken = exports.Token = undefined;\n\n\tvar _utils = __webpack_require__(5);\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/**\n\t * Token is a base class for all token types parsed.  Note we don't actually\n\t * use intheritance due to IE8's non-existent ES5 support.\n\t */\n\tvar Token =\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} type The type of the Token.\n\t * @param {Number} length The length of the Token text.\n\t */\n\texports.Token = function Token(type, length) {\n\t  _classCallCheck(this, Token);\n\n\t  this.type = type;\n\t  this.length = length;\n\t  this.text = '';\n\t};\n\n\t/**\n\t * CommentToken represents comment tags.\n\t */\n\n\n\tvar CommentToken = exports.CommentToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} content The content of the comment\n\t   * @param {Number} length The length of the Token text.\n\t   */\n\t  function CommentToken(content, length) {\n\t    _classCallCheck(this, CommentToken);\n\n\t    this.type = 'comment';\n\t    this.length = length || (content ? content.length : 0);\n\t    this.text = '';\n\t    this.content = content;\n\t  }\n\n\t  CommentToken.prototype.toString = function toString() {\n\t    return '<!--' + this.content;\n\t  };\n\n\t  return CommentToken;\n\t}();\n\n\t/**\n\t * CharsToken represents non-tag characters.\n\t */\n\n\n\tvar CharsToken = exports.CharsToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {Number} length The length of the Token text.\n\t   */\n\t  function CharsToken(length) {\n\t    _classCallCheck(this, CharsToken);\n\n\t    this.type = 'chars';\n\t    this.length = length;\n\t    this.text = '';\n\t  }\n\n\t  CharsToken.prototype.toString = function toString() {\n\t    return this.text;\n\t  };\n\n\t  return CharsToken;\n\t}();\n\n\t/**\n\t * TagToken is a base class for all tag-based Tokens.\n\t */\n\n\n\tvar TagToken = exports.TagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} type The type of the token.\n\t   * @param {string} tagName The tag name.\n\t   * @param {Number} length The length of the Token text.\n\t   * @param {Object} attrs The dictionary of attributes and values\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   */\n\t  function TagToken(type, tagName, length, attrs, booleanAttrs) {\n\t    _classCallCheck(this, TagToken);\n\n\t    this.type = type;\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.unary = false;\n\t    this.html5Unary = false;\n\t  }\n\n\t  /**\n\t   * Formats the given token tag.\n\t   *\n\t   * @param {TagToken} tok The TagToken to format.\n\t   * @param {?string} [content=null] The content of the token.\n\t   * @returns {string} The formatted tag.\n\t   */\n\n\n\t  TagToken.formatTag = function formatTag(tok) {\n\t    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t    var str = '<' + tok.tagName;\n\t    for (var key in tok.attrs) {\n\t      if (tok.attrs.hasOwnProperty(key)) {\n\t        str += ' ' + key;\n\n\t        var val = tok.attrs[key];\n\t        if (typeof tok.booleanAttrs === 'undefined' || typeof tok.booleanAttrs[key] === 'undefined') {\n\t          str += '=\"' + (0, _utils.escapeQuotes)(val) + '\"';\n\t        }\n\t      }\n\t    }\n\n\t    if (tok.rest) {\n\t      str += ' ' + tok.rest;\n\t    }\n\n\t    if (tok.unary && !tok.html5Unary) {\n\t      str += '/>';\n\t    } else {\n\t      str += '>';\n\t    }\n\n\t    if (content !== undefined && content !== null) {\n\t      str += content + '</' + tok.tagName + '>';\n\t    }\n\n\t    return str;\n\t  };\n\n\t  return TagToken;\n\t}();\n\n\t/**\n\t * StartTagToken represents a start token.\n\t */\n\n\n\tvar StartTagToken = exports.StartTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The tag name.\n\t   * @param {Number} length The length of the Token text\n\t   * @param {Object} attrs The dictionary of attributes and values\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   * @param {boolean} unary True if the tag is a unary tag\n\t   * @param {string} rest The rest of the content.\n\t   */\n\t  function StartTagToken(tagName, length, attrs, booleanAttrs, unary, rest) {\n\t    _classCallCheck(this, StartTagToken);\n\n\t    this.type = 'startTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.html5Unary = false;\n\t    this.unary = unary;\n\t    this.rest = rest;\n\t  }\n\n\t  StartTagToken.prototype.toString = function toString() {\n\t    return TagToken.formatTag(this);\n\t  };\n\n\t  return StartTagToken;\n\t}();\n\n\t/**\n\t * AtomicTagToken represents an atomic tag.\n\t */\n\n\n\tvar AtomicTagToken = exports.AtomicTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The name of the tag.\n\t   * @param {Number} length The length of the tag text.\n\t   * @param {Object} attrs The attributes.\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   * @param {string} content The content of the tag.\n\t   */\n\t  function AtomicTagToken(tagName, length, attrs, booleanAttrs, content) {\n\t    _classCallCheck(this, AtomicTagToken);\n\n\t    this.type = 'atomicTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.unary = false;\n\t    this.html5Unary = false;\n\t    this.content = content;\n\t  }\n\n\t  AtomicTagToken.prototype.toString = function toString() {\n\t    return TagToken.formatTag(this, this.content);\n\t  };\n\n\t  return AtomicTagToken;\n\t}();\n\n\t/**\n\t * EndTagToken represents an end tag.\n\t */\n\n\n\tvar EndTagToken = exports.EndTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The name of the tag.\n\t   * @param {Number} length The length of the tag text.\n\t   */\n\t  function EndTagToken(tagName, length) {\n\t    _classCallCheck(this, EndTagToken);\n\n\t    this.type = 'endTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t  }\n\n\t  EndTagToken.prototype.toString = function toString() {\n\t    return '</' + this.tagName + '>';\n\t  };\n\n\t  return EndTagToken;\n\t}();\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.escapeQuotes = escapeQuotes;\n\n\t/**\n\t * Escape quotes in the given value.\n\t *\n\t * @param {string} value The value to escape.\n\t * @param {string} [defaultValue=''] The default value to return if value is falsy.\n\t * @returns {string}\n\t */\n\tfunction escapeQuotes(value) {\n\t  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n\t  // There's no lookback in JS, so /(^|[^\\\\])\"/ only matches the first of two `\"`s.\n\t  // Instead, just match anything before a double-quote and escape if it's not already escaped.\n\t  return !value ? defaultValue : value.replace(/([^\"]*)\"/g, function (_, prefix) {\n\t    return (/\\\\/.test(prefix) ? prefix + '\"' : prefix + '\\\\\"'\n\t    );\n\t  });\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports['default'] = fixedReadTokenFactory;\n\t/**\n\t * Empty Elements - HTML 4.01\n\t *\n\t * @type {RegExp}\n\t */\n\tvar EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i;\n\n\t/**\n\t * Elements that you can intentionally leave open (and which close themselves)\n\t *\n\t * @type {RegExp}\n\t */\n\tvar CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i;\n\n\t/**\n\t * Corrects a token.\n\t *\n\t * @param {Token} tok The token to correct\n\t * @returns {Token} The corrected token\n\t */\n\tfunction correct(tok) {\n\t  if (tok && tok.type === 'startTag') {\n\t    tok.unary = EMPTY.test(tok.tagName) || tok.unary;\n\t    tok.html5Unary = !/\\/>$/.test(tok.text);\n\t  }\n\t  return tok;\n\t}\n\n\t/**\n\t * Peeks at the next token in the parser.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Function} readTokenImpl The underlying readToken implementation\n\t * @returns {Token} The next token\n\t */\n\tfunction peekToken(parser, readTokenImpl) {\n\t  var tmp = parser.stream;\n\t  var tok = correct(readTokenImpl());\n\t  parser.stream = tmp;\n\t  return tok;\n\t}\n\n\t/**\n\t * Closes the last token.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Array<Token>} stack The stack\n\t */\n\tfunction closeLast(parser, stack) {\n\t  var tok = stack.pop();\n\n\t  // prepend close tag to stream.\n\t  parser.prepend('</' + tok.tagName + '>');\n\t}\n\n\t/**\n\t * Create a new token stack.\n\t *\n\t * @returns {Array<Token>}\n\t */\n\tfunction newStack() {\n\t  var stack = [];\n\n\t  stack.last = function () {\n\t    return this[this.length - 1];\n\t  };\n\n\t  stack.lastTagNameEq = function (tagName) {\n\t    var last = this.last();\n\t    return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase();\n\t  };\n\n\t  stack.containsTagName = function (tagName) {\n\t    for (var i = 0, tok; tok = this[i]; i++) {\n\t      if (tok.tagName === tagName) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  };\n\n\t  return stack;\n\t}\n\n\t/**\n\t * Return a readToken implementation that fixes input.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Object} options Options for fixing\n\t * @param {boolean} options.tagSoupFix True to fix tag soup scenarios\n\t * @param {boolean} options.selfCloseFix True to fix self-closing tags\n\t * @param {Function} readTokenImpl The underlying readToken implementation\n\t * @returns {Function}\n\t */\n\tfunction fixedReadTokenFactory(parser, options, readTokenImpl) {\n\t  var stack = newStack();\n\n\t  var handlers = {\n\t    startTag: function startTag(tok) {\n\t      var tagName = tok.tagName;\n\n\t      if (tagName.toUpperCase() === 'TR' && stack.lastTagNameEq('TABLE')) {\n\t        parser.prepend('<TBODY>');\n\t        prepareNextToken();\n\t      } else if (options.selfCloseFix && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) {\n\t        if (stack.lastTagNameEq(tagName)) {\n\t          closeLast(parser, stack);\n\t        } else {\n\t          parser.prepend('</' + tok.tagName + '>');\n\t          prepareNextToken();\n\t        }\n\t      } else if (!tok.unary) {\n\t        stack.push(tok);\n\t      }\n\t    },\n\t    endTag: function endTag(tok) {\n\t      var last = stack.last();\n\t      if (last) {\n\t        if (options.tagSoupFix && !stack.lastTagNameEq(tok.tagName)) {\n\t          // cleanup tag soup\n\t          closeLast(parser, stack);\n\t        } else {\n\t          stack.pop();\n\t        }\n\t      } else if (options.tagSoupFix) {\n\t        // cleanup tag soup part 2: skip this token\n\t        readTokenImpl();\n\t        prepareNextToken();\n\t      }\n\t    }\n\t  };\n\n\t  function prepareNextToken() {\n\t    var tok = peekToken(parser, readTokenImpl);\n\t    if (tok && handlers[tok.type]) {\n\t      handlers[tok.type](tok);\n\t    }\n\t  }\n\n\t  return function fixedReadToken() {\n\t    prepareNextToken();\n\t    return correct(readTokenImpl());\n\t  };\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prescribe/dist/prescribe.js\n// module id = 3\n// module chunks = 0","/**\n * Determine if the thing is not undefined and not null.\n *\n * @param {*} thing The thing to test\n * @returns {boolean} True if the thing is not undefined and not null.\n */\nexport function existy(thing) {\n  return thing !== void 0 && thing !== null;\n}\n\n/**\n * Is this a function?\n *\n * @param {*} x The variable to test\n * @returns {boolean} True if the variable is a function\n */\nexport function isFunction(x) {\n  return 'function' === typeof x;\n}\n\n/**\n * Loop over each item in an array-like value.\n *\n * @param {Array<*>} arr The array to loop over\n * @param {Function} fn The function to call\n * @param {?Object} target The object to bind to the function\n */\nexport function each(arr, fn, target) {\n  let i;\n  const len = (arr && arr.length) || 0;\n  for (i = 0; i < len; i++) {\n    fn.call(target, arr[i], i);\n  }\n}\n\n/**\n * Loop over each key/value pair in a hash.\n *\n * @param {Object} obj The object\n * @param {Function} fn The function to call\n * @param {?Object} target The object to bind to the function\n */\nexport function eachKey(obj, fn, target) {\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn.call(target, key, obj[key]);\n    }\n  }\n}\n\n/**\n * Set default options where some option was not specified.\n *\n * @param {Object} options The destination\n * @param {Object} _defaults The defaults\n * @returns {Object}\n */\nexport function defaults(options, _defaults) {\n  options = options || {};\n  eachKey(_defaults, function(key, val) {\n    if (!existy(options[key])) {\n      options[key] = val;\n    }\n  });\n  return options;\n}\n\n/**\n * Convert value (e.g., a NodeList) to an array.\n *\n * @param {*} obj The object\n * @returns {Array<*>}\n */\nexport function toArray(obj) {\n  try {\n    return Array.prototype.slice.call(obj);\n  } catch (e) {\n    const ret = [];\n    each(obj, function(val) {\n      ret.push(val);\n    });\n    return ret;\n  }\n}\n\n/**\n * Get the last item in an array\n *\n * @param {Array<*>} array The array\n * @returns {*} The last item in the array\n */\nexport function last(array) {\n  return array[array.length - 1];\n}\n\n/**\n * Test if token is a script tag.\n *\n * @param {Object} tok The token\n * @param {String} tag The tag name\n * @returns {boolean} True if the token is a script tag\n */\nexport function isTag(tok, tag) {\n  return !tok ||\n    !(tok.type === 'startTag' || tok.type === 'atomicTag') ||\n    !('tagName' in tok) ? !1 : !!~tok.tagName.toLowerCase().indexOf(tag);\n}\n\n/**\n * Test if token is a script tag.\n *\n * @param {Object} tok The token\n * @returns {boolean} True if the token is a script tag\n */\nexport function isScript(tok) {\n  return isTag(tok, 'script');\n}\n\n/**\n * Test if token is a style tag.\n *\n * @param {Object} tok The token\n * @returns {boolean} True if the token is a style tag\n */\nexport function isStyle(tok) {\n  return isTag(tok, 'style');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,SAAAA,iCAAAC,IAAA,EAAAC,OAAA;EACD,W,oDCVAC,MAAA,CAAAC,OAAA,GAAAF,OAAA,QACA,WAAAG,MAAA,mBAAAA,MAAA,CAAAC,GAAA,E,yBAEA,WAAAF,OAAA,eACAA,OAAA,iBAAAF,OAAA,QAEAD,IAAA,iBAAAC,OAAA;AACA;EACA,yBAAAK,OAAA;IAAA;;IAEA;IAAA,IAAAC,gBAAA;IACA;IACA;IACA;IAAA,SAAAC,oBAAAC,QAAA;MACA;MACA;8CAEA,eAAAF,gBAAA,CAAAE,QAAA,EAAAN,OAAA;MACA;;MAEA;MAAA,IAAAD,MAAA,GAAAK,gBAAA,CAAAE,QAAA;QACA,QAAAN,OAAA;;QAEA,QAAAO,MAAA;QACA;MAAA;MACA;;;;MAGA;MACA;;;MAEA;MACA;;;MAEA;IAAA;IACA;;IAEA;IACA;IAAAF,mBAAA,CAAAG,CAAA,GAAAL,OAAA;;;;;;;;;;;ICtCA;IAAA,OAAAE,mBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICMA,IAAAI,KAAS,GAAAC,uBACR,CAAAC,MAAA;IAED,SAAAD,wBAAAE,GAAA;MAAA,IAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA;QAAA,OAAAD,GAAA;MAAA;QAAA,IAAAE,MAAA;QAAA,IAAAF,GAAA;UAAA,SAAAG,GAAA,IAAAH,GAAA;YAAA,IAAAI,MAAA,CAAAC,SAAA,CAAAC,cAAA,CAAAC,IAAA,CAAAP,GAAA,EAAAG,GAAA,GAAAD,MAAA,CAAAC,GAAA,IAAAH,GAAA,CAAAG,GAAA;UAAA;QAAA;QAAAD,MAAA,cAAAF,GAAA;QAAA,OAAAE,MAAA;MAAA;IAAA;;;;;;;;AAKA;AACE;;;IAGA;;AAEA;;;IAGA,IAAAM,OAAA;;AAEA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;AAAkB;MAAAC,aApCJ,EAAAC,SAAA;MAsCd;;;;;MAKAC,gBAAa,WAAAA,iBAAAC,GAAA;QAAA,OAAOA,GAAP;MAAA,CA3CC;MA6Cd;;;AAGA;;MAEAC,WAAA,WAAAA,YAAAC,GAAA;;;;AAKA;AAAW;MAAyBC,IAvDtB,EAAAL,SAAA;;AAyDd;;;AAGA;MA5DFM,KAAA,WAAAA,MAAAC,CAAA;;MA+DA;;AAIA;AACE;MACAC,YAAU;IACR;IAEA,IAAAC,MAAA,GAAQ;IACR,IAAAC,KAAK;IACL,IAAAC,MAAA,GAAQ;IAEX,SAAAC,WAAA;;MAED,IAAAC,IAAS;QACP,IAAAC,OAAS,GAAA3B,KAAA,CAAA4B,IAAA,CAAAF,IAAA;QAETC,OAAA,CAAAE,YAAA;QACAH,IAAA,CAAOI,MAAK,GAAAC,SAAZ,CAAAC,KAAA,CAAAC,SAAA,EAAAP,IAAA;QACAC,OAAO,CAAAO,gBAAO;MACd;;IAGA,SAAMH,SAASA,CAAAI,EAAA,EAAAC,IAAA,EAAfT,OAAA;;;MAGE;MACAH,MAAA,CAAAa,EAAM,GAAIf,MAFE;MAGZE,MAAA,CAAAc,IAAO,GAAIX,OAHC,CAAAW,IAAA,IAAAd,MAAA,CAAAa,EAAA;MAIZE,UAAA,CAASC,OAAI,CAAAhB,MAAA,CAAAc,IAAA,IAAAd,MAAA;;;MAGf,IAAAiB,GAAA,GAASN,EAAA,CAAAO,aAAW;MAElB,IAAAC,KAAO;QACPC,KAAA,EAAAH,GAAQ,CAAAG,KAAA;QACTC,IAAA,EAAAJ,GAAA,CAAAI,IAAA;;QAEDC,OAAc,EAAAL,GAAK,CAAAK;MACjB;MAEA,SAAOC,OAAA9B,GAAA;QAAAA,GAAA,GAAAU,OAAA,CAAAX,WAAA,CAAAC,GAAA;QAAIO,MAAA,CAAJwB,KAAA,CAAA/B,GAAA;QAAAU,OAAA,CAAAsB,UAAA,CAAAhC,GAAA;;MAAAiC,QAHU,CAAAT,GAAA;QAIjBG,KAAA,EAAA/B,SAAS;QAAAgC,IAAA,EAAAhC,SAAA;QAAImC,KAAA,EAAJ,SAAAA,MAAA;UAAA,SAAAG,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAApC,GAAA,GAAAqC,KAAA,CAAAH,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;;UAAA;UAJX,OAAAR,MAAA,CAAA9B,GAAA,CAAAuC,IAAA;;QAOAV,OAAA,WAAAA,QAAA;UACM,SAAAW,KAAa,GAAAL,SAAW,CAAAC,MAAX,EAAsBpC,GAAA,GAAAqC,KAAzC,CAAAG,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;;UAEA;UAEA,OAAWX,MAAA,CAAX9B,GAAqB,CAAAuC,IAAA,OAAC,IAAK;QACzB;MACA;;;MAGF,IAAAG,UAAA,GAAAnC,MAAA,CAAAoC,GAAA,CAAAC,OAAA,IAAAhD,SAAA;;MAEE;MACA;;QAEAc,OAAA,CAAAR,KAAA;UAAA2C,GAAA,EAAAA,GAAA,WAAAC,GAAA,UAAAC;QAAA;QACAL,UAAA,CAAW3B,KAAA,CAAAR,MAAU,CAAAoC,GAAA,GAAAE,GAArB,EAAAC,GAAA,EAAAC,IAAA;;;MAGA;MACAxC,MAAA,CAAAwB,KAAA,CAAAZ,IAAA;QATF;;;QAaD;;QAGCT,OAAI,CAAMT,IAAA;QACRM,MAAA,OAAW;QADbC,UAEW;MACT;MAEA,OAAAD,MAAA;IACA;;MAGF,IAAAxB,KAAA,CAAUiE,UAAM,CAAAtC,OAAS;;;;MAEzB,WAAAA,OAAA;QACAJ,KAAK,GAAM;QACTC,MAAK,OAAO;QADdF,MAEO;QACL;MACD;MAEDK,OAAM,GAAA3B,KAAO,CAAKkE,QAAM,CAAAvC,OAAxB,EAAAhB,OAAA;;MAEA;MACE,SAAAwD,IAAQ,CAAAhC,EAAA;QACNA,EAAA,GAAAiC,MAAS,CAAAC,QAAQ,CAAAC,cAAA,CAAAnC,EAAA,CAAAoC,MAAA;MACf;QACDpC,EAAA,GAFDA,EAAA,CAAAqC,MAEO,GAAArC,EAAA,MAAAA,EAAA;MACL;MAEH,IAAAT,IAAA,IAAAS,EAAA,EAAAC,IAAA,EAAAT,OAAA;;QAGH8C,MAAQ,WAAAA,MAAcA,CAAA,EAAtB;UACA,IAAM/C,IAAK,CAAAI,MAAX;;UAEI,CAAC,MAAL;YACEJ,IAAA,MAAAb,SAAA;UACD;;MAED;;MAGFU,KAAA,CAAAmD,IAAc,CAAAhD,IAAA;MAEZ,KAAAF,MAFwB;QAGxBC,UAAA;MACA;MAEA,OAAAU,EAAA,CAAAI,UAAA;IANwB;;;;;;;;;;;KC9L1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;;AAEA;;;;;;;IAOA,IAAAoC,YAAA,cAA2B;;;AAGzB;;AAEA;AACA;AACD;;IAED,SAAAC,QAAAzC,EAAA,EAAAG,IAAA;;;;;;IAOA;;;AACE;;AAEA;AACE;AACD;AACC;IACD,SAAAuC,QAAA1C,EAAA,EAAAG,IAAA;MACF,IAAAwC,KAAA,GAAA1B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAnB,SAAA,GAAAmB,SAAA;MAED,IAAA2B,IAAA,GAAAC,QAAA,GAAA1C,IAAA;;;;;;;;;;;;;;;;;;;;;;;;AAwBE;;;;;;AAMA;;;MAAgC;;AAC9B;AACA;AACA;AACA;MACA,SAAK2C,WAASC,CAAA9F,IAAA;;QAGd+F,eAAe,CAAC,IAAD,EAAfF,WAAA;QAEA,KAAA7F,IAAA,GAAAA,IAAA;QACA,KAAAuC,OAAA,GAAAA,OAAA;QACA,KAAKc,GAAA,GAAArD,IAAA,CAAAsD,aAAL;;QAEA,KAAAwC,MAAA,OAAAE,WAAA;UAAAC,OAAA,EAAA1D,OAAA,CAAA0D;QAAA;;;QAGA,KAAKC,OAAA,IAALlG,IAAmB,CAAnB;;;QAGA;QACD,KAAAmG,YAAA;;QAED;;;;;;;;AAME;;AAEA;AACA;;MAGEN,WAAM,CAAAzE,SAAW,CAAAwC,KAAA,GAAW,SAA5BA,MAAA;;QAGE,CAAAwC,WAAK,QAAAC,UAAL,EAAAf,IAAA,CAAA1C,KAAA,CAAAwD,WAAA,EAAApC,SAAA;;QAEA;QACD;QACF;;;;;;;;;;;MAUD;AACA;AACA;AACA;AACD;;;;;;;;;;;;;MASC;;AAEA;AACA;AACA;AACA;;MAGA6B,WAAQ,CAAAzE,SAAW,CAAAkF,UAAO,YACxBA,UAAEA,CAAStD,IAAA,EAAM;QAEjB,KAAA8C,MAAM,CAAAS,MAAK,CAAAvD,IAAQ;QAEnB,IAAArB,GAAI,GAAJ,KAAS;QACP,IAAA6E,MAAA,GAAO,KAAK,CAAZ;QACD,IAAAC,KAAA;QACF,IAAAC,MAAA;;QAED;QACE,OAAK,CAAA/E,GAAA,QAAAmE,MAAL,CAAwBa,SAAxB,SAAAH,MAAA,GAAA5F,KAAA,CAAAgG,QAAA,CAAAjF,GAAA,QAAA8E,KAAA,GAAA7F,KAAA,CAAAiG,OAAA,CAAAlF,GAAA;UACDA,GAAA,QAAAY,OAAA,CAAAb,gBAAA,CAAAC,GAAA;UAED,IAAIA,GAAA,EAAJ;YACE+E,MAAK,CAAApB,IAAA,CAAA3D,GAAA;UACN;;QAGC,IAAA+E,MAAK,CAAAzC,MAAA;UACN,KAAA6C,kBAAA,CAAAJ,MAAA;;QAGH,IAAAF,MAAA;;;;;;;;;AAQE;;AAEA;AACE;AACA;AACD;;MAGDX,WAAK,CAAAzE,SAAL,CAAA0F,kBAAA,YAAAA,mBAAAJ,MAAA;QACA,IAAAK,KAAK,OAAU,CAAAC,WAAY,CAAAN,MAAM;QAEjC,IAAI,CAAAK,KAAA,CAAAE,MAAa;UACf;UACD;;;QAID,IAAI,CAAAd,YAAa,IAAAY,KAAA,CAAAG,KAAA;QACf,KAAAC,SAAM,CAAAC,SAAN,GAAwBL,KAAK,CAAA/D,IAAK;;UAGpC+D,KAAO,CAAAM,cAAP,QAAAF,SAAA,CAAAC,SAAA;;QAGF,KAAAE,UAAA;;;;;;;;AAQE;;AAEA;AACA;;AAEA;;MAGAzB,WAAA,CAAAzE,SAAA,CAAA4F,WAAA,YAAAA,YAAAN,MAAA;QACA,IAAMxE,MAAA,GAAQ,IAAd,CAAAgE,OAAA,CAAAjC,MAAA;;QAEA;QACA,IAAAsD,GAAK,GAAI;;QAEP;;;;QAIA,IAAAL,KAAI,GAAI;QACN,IAAAM,GAAA,GAAAd,MAAA,CAAAzC,MAAA;QACA,SAAMwD,CAAA,MAAAA,CAAA,GAAAD,GAAe,EAAAC,CAAA,EAAK;UACxB,IAAA9F,GAAA,GAAM+E,MAAK,CAAAe,CAAA;;UAGXF,GAAA,CAAAjC,IAAA,CAAAoC,QAAY;UAEZ,IAAA/F,GAAA,CAAAgG,KAAA;YACA;YACE;YACA,mBAAA5C,IAAA,CAAApD,GAAA,CAAAiG,OAAA;cACE,IAAA3E,EAAA,GAAAf,MAAA;;cAIH;cACF+E,MAAA,CAAA3B,IAAA,CAAAoC,QAAA,CAAAG,OAAA,iBAAAjC,QAAA,WAAA3C,EAAA;;cAED;cACA,IAAAtB,GAAA,CAAAgG,KAAA,CAAA1E,EAAA,KAAAsC,YAAA,IAAA5D,GAAA,CAAAgG,KAAA,CAAA1E,EAAA,KAAA6E,WAAA;gBACA;;gBAEA;gBACAnG,GAAM,CAAAoG,IAAK,KAAI,WAAS,KAAb,GAAwB,MAAApG,GAAxB,CAAmCiG,OAA9C,SAAAhC,QAAA,gBAAA3C,EAAA,IAAAtB,GAAA,CAAAqG,KAAA;cACD;YACF;;YAED;YACE;YACAf,MAAK,CAAI3B,IAAJ,CAASoC,QAFT;;YAIL;YAJFR,KAAA,CAAA5B,IAAA,CAAA3D,GAAA,CAAAoG,IAAA,gBAAAL,QAAA;;;;;;;;;;;MAeA;;AAEA;AACA;AACE;;MAGA7B,WAAA,CAAAzE,SAAA,CAAAkG,UAAA,YAAAA,WAAA;QACA,IAAAW,IAAK,QAAS;QACZ,IAAAC,KAAI,QAAJ,CAAAf,SAAe;;QAEb;QACA,OAAAvG,KAAA,CAAAuH,MAAA,CAAcF,IAAd,GAAAC,KAAA,CAAAE,KAAA;UACD,IAAAC,SAAA,GAAAJ,IAAA,CAAAK,QAAA;;;UAGD;UAEA,KAAAC,OAAI;YACF,IAAAF,SAAA;cACA;cACD,KAAAnC,OAAA,CAAAV,OAAA,CAAAyC,IAAA,WAAAA,IAAA;cACFxC,OAAA,CAAAwC,IAAA;;;YAGD;YACD,IAAAO,eAAA,GAAAP,IAAA,CAAAQ,UAAA,IAAAjD,OAAA,CAAAyC,IAAA,CAAAQ,UAAA;;;cAGH,KAAAvC,OAAA,CAAAsC,eAAA,EAAAE,WAAA,CAAAT,IAAA;;;;;;;;;;AAME;;AAEA;AACE;;;QAIF,IAAIU,KAAJ,GAAU,IAAI;QAEd,IAAAC,SAAW,OAAQ,CAAA9C,MAAA,CAAA+C,KAAA,EAAb;QAEJ,IAAAD,SAAA;UACA;UACD,KAAAvC,UAAA,CAAAyC,OAAA,CAAAF,SAAA;;QAGCjH,GAAA,CAAAoH,GAAA,GAAApH,GAAA,CAAAgG,KAAA,CAAAoB,GAAA,IAAApH,GAAA,CAAAgG,KAAA,CAAAqB,GAAA;QAEArH,GAAA,QAAAY,OAAA,CAAAb,gBAAA,CAAAC,GAAA;QACA,KAAAA,GAAK;UAJP;UAME;QACD;QAED,IAAAA,GAAA,CAAAoH,GAAA,SAAAE,WAAA,CAAAhF,MAAA;UACA;UACE;UADF;;;UAKF,KAAAiF,cAAA,CAAAvH,GAAA;;;;;;;;;;AAQE;AACE;AACA;AACD;;;QAID,IAAAiH,SAAW,OAAQ,CAAA9C,MAAA,CAAA+C,KAAA,EAAb;QAEN,IAAID,SAAK;UACP;UACA,KAAKvC,UAAA,CAAAyC,OAAiB,CAAAF,SAAtB;QACD;QAEDjH,GAAA,CAAIoG,IAAA,GAAApG,GAAJ,CAAegG,KAAA,CAAAI,IAAA,IAAApG,GAAA,CAAAgG,KAAA,CAAAwB,IAAA;QAEdxH,GAAA,QAAAY,OAAA,CAAAb,gBAAA,CAAAC,GAAA;;UAGH;;;;;;;;;AAQE;;AAEA;AACA;;MAGGkE,WAAM,CAAAzE,SAAA,CAAAgI,gBAAA,YAAAA,iBAAAzH,GAAA;QACL,IAAAoB,EAAA,GAAG,KAAAsG,WAAiB,CAAA1H,GAAI;QAE3B,KAAA2H,aAAA,CAAAvG,EAAA,EAAA+E,WAAA;;;QAGH,IAAAnG,GAAA,CAAA4H,OAAA;;;;;;;;;MAOE;;AAEA;;AAEA;AACA;;;QAIA,IAAAxG,EAAA,QAAAM,GAAA,CAAAmG,aAAA,CAAA7H,GAAA,CAAAiG,OAAA;;;;;;;;;;;AAWA;;AAEA;;AAEA;AACE;;;QAIJ,KAAAtB,UAAA,gBAAAmD,KAAA;;;;;;;MAOE;AACA;AACA;AACD;;AAED;;;;;;;;MAOE;AACA;AACE;AACA;AACD;;;MAID5D,WAAA,CAAAzE,SAAA,CAAAsI,aAAA,YAAAA,cAAA/H,GAAA;QACA;;UAEA,KAAAY,OAAA,CAAAR,KAAA;YAAA2C,GAAA;UAAA;;QAEA;QAEA,KAAAuE,WAAA,CAAAb,KAAA;;QAEE;QACA,KAAAxE,KAAK,CAAAhB,KAAA,KAAL,EAAAjB,GAAsB,CAAAgI,WAAtB;;;;QAIJ;;;;;;;;;;AAQE;AACA;AACA;;AAEA;AACE;;MAGE9D,WAAA,CAAAzE,SAAA,CAAAwI,iBAAA,YAAAA,kBAAAjI,GAAA,EAAAG,IAAA;QACA,IAAAiB,EAAA,QAAA8G,YAAA,CAAAlI,GAAA;QACD,IAH2BmI,YAA5B,QAAAC,cAAA,CAAAhH,EAAA;QAID,IAAAiH,UAAA,QAAAzH,OAAA,CAAAyH,UAAA;QAED,IAAIrI,GAAA,CAAAoH,GAAA;UACF;UACAhG,EAAA,CAAAgG,GAAK,GAAGpH,GAAJ,CAAAoH,GAAW;UACb,KAAAkB,kBAAA,CAAAlH,EAAA,GAAA+G,YAAA;YACDhI,IAAA;YACDkI,UAAU;UACV,IAAAA,UAAa;QACb;;;UAIJ,KAAAjH,EAAA,CAAAgG,GAAA,IAAAe,YAAA;;;;;;;;;MAOE;;AAEA;AACA;AACE;AACD;;MAGDjE,WAAQ,CAAAzE,SAAS,CAAAyI,YAAA,YAAAA,aAAAlI,GAAA;QACf,IAAAoB,EAAG,GAAH,IAAU,CAAAM,GAAI,CAAAmG,aAAd,CAAA7H,GAAA,CAAAiG,OAAA;;;QAGFhH,KAAA,CAAAsJ,OAAA,CAAAvI,GAAA,CAAAgG,KAAA,YAAAzE,IAAA,EAAAwC,KAAA;;;;;;;;;;;;AAWA;AACE;AACD;;AAED;;;MAIEG,WAAI,CAAAzE,SAAJ,CAAkB6I,kBAAA,YAAAA,mBAAAlH,EAAA,EAAAjB,IAAA;QAChB,SAAAqI,QAAA;UACDpH,EAAA,GAAAA,EAAA,CAAAqH,MAAA,GAAArH,EAAA,CAAAsH,kBAAA,GAAAtH,EAAA,CAAA0B,OAAA;QACD;;QAIA,SAAA6F,QAAA;UACAH,OAAM,EAAN;UACA,IAAIrI,IAAA,IAAQ,IAAZ,EAAkB;YAChBA,IAAA;UACD;UACDA,IAAA,GAAO,IAAP;QACD;QAED,SAASyI,QAAAC,GAAA;UACPL,OAAM;UACNpI,KAAI,CAAAyI,GAAA;UACF,IAAA1I,IAAA;YACDA,IAAA;UACF;;QAED;;UAGA,IAAA2I,OAAkB,GAAA1H,EAAA,QAAA2H,GAAA;UAChB,IAAAD,OADgB;YAEd1H,EAAA,MAAO,GAAA2H,GAAP,IAAgBD,OAAA;UACd;QACE;QAEAE,qBAAS,CAAA5H,EAAA;QACV4H,qBAAA,CAAA5H,EAAA;QAEHe,QAAA,CAAAf,EAAA;UACDqH,MAVe,WAAAA,OAAA;YAYhB,IAAArH,EAZgB,CAAA6H,OAAA;cAad,IAAI;gBACF7H,EAAI,CAAA6H,OAAA,CAAAhI,KAAA,OAAAsB,KAAA,CAAA9C,SAAA,CAAAyJ,KAAA,CAAAvJ,IAAA,CAAA0C,SAAA;cACF,SAAGwG,GAAA,EAAS;gBACZD,OAAO;kBAAP7F,GAAY,6BAAA8F,GAAA,WAAAzH,EAAA,CAAAgG;gBAAA;cACZ;YACA;YACDuB,OAAA;UACF;UACD7F,OAAA,WAASA,QAAA;YArBK,IAAA1B,EAAA,CAAA+H,QAAA;cAwBhB;gBACM/H,EAAA,CAAA+H,QAAA,CAAAlI,KAAA,KAAsB,EAAAsB,KAAK,CAAG9C,SAAA,CAA9ByJ,KAA2C,CAAAvJ,IAAA,CAAA0C,SAAA;cAC7C,SAAAwG,GAAA;gBACDD,OAAA;kBAAA7F,GAAA,8BAAA8F,GAAA,WAAAzH,EAAA,CAAAgG;gBAAA;gBACF;cA5BH;;;;;UAgCF;;;;;;;;;;AAQE;AACA;AACD;;;;;;;;;MCrmBH,OAAAlD,WAAA;IACA;IAEA1F,OAAA,cAAA0F,WAAA;;IAEA;EAAA,GACA;EACA,eAAA3F,MAAA,EAAAC,OAAA,EAAAK,mBAAA;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA,CAAC,SAAAT,iCAAAC,IAAA,EAAAC,OAAA;MACD,UACAC,MAAA,CAAAC,OAAA,GAAAF,OAAA,QACA,WAAAG,MAAA,mBAAAA,MAAA,CAAAC,GAAA,E,yBAEA,WAAAF,OAAA,eACAA,OAAA,gBAAAF,OAAA,QAEAD,IAAA,gBAAAC,OAAA;IACA;MACA,yBAAAK,OAAA;QAAA;;QAEA;QAAA,IAAAC,gBAAA;;QAEA;QACA;QAAA,SAAAC,oBAAAC,QAAA;UAEA;kDAEA,eAAAF,gBAAA,CAAAE,QAAA,EAAAN,OAAA;;;UAGA;UAAA,IAAAD,MAAA,GAAAK,gBAAA,CAAAE,QAAA;YACA,QAAAN,OAAA;;YAEA,QAAAO,MAAA;YACA;UAAA;;;;;;UAKA;;;;UAGA;;;UAEA;QAAA;;QAGA;QACA;QAAAF,mBAAA,CAAAG,CAAA,GAAAL,OAAA;;QAEA;QACA;QAAAE,mBAAA,CAAAuK,CAAA,GAAAxK,gBAAA;;QAEA;;;;;QAIA;QAAA,OAAAC,mBAAA;;;MAEA;gBAEA;;;;QAKA,IAAAwK,WAAA,GAAAxK,mBAAA;;;;;;;;;;SASA;;;;;;;;;;;QAmBA,IAAAM,MAAA,GAAAN,mBAAA;QAEA,SAAAyK,uBAAAlK,GAAA;UAAA,OAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA;YAAA,WAAAA;UAAA;QAAA;;;;;;;;;;;;;;;QAIA,SAAAgF,gBAAAmF,QAAA,EAAAC,WAAA;UAAA,MAAAD,QAAA,YAAAC,WAAA;YAAA,UAAAC,SAAA;UAAA;QAAA;;QAEA;AACA;AACA;AACA;AACA;AACA;;QAGA,IAAAC,MAAA;UACAC,OAAA;UACAC,MAAA;;UAEAC,QAAA;UACAC,KAAA;QACA;;QAEA;AACA;AACA;AACA;;QAEA,IAAAC,UAAA;;AAEA;AACA;;AAEA;;AAEA;;YAEA,IAAA/C,KAAA;;YAGA,IAAApG,OAAA,GAAAyB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAnB,SAAA,GAAAmB,SAAA;YAEA+B,eAAA,OAAA2F,UAAA;YAEA,KAAAhJ,MAAA,GAAAA,MAAA;YAEA,IAAAiJ,GAAA;YACA,IAAAC,iBAAA;YAEA,SAAA1K,GAAA,IAAA2K,QAAA;cACA,IAAAA,QAAA,CAAAxK,cAAA,CAAAH,GAAA;gBACA,IAAAqB,OAAA,CAAA0D,OAAA;kBACQ2F,iBAAA,CAAA1K,GAAA;gBACR;gBACAyK,GAAA,GAAAA,GAAA,IAAAC,iBAAA,CAAA1K,GAAA;cACA;YACA;YAEA,IAAAyK,GAAA;cACA,KAAAG,UAAA,OAAAC,uBAAA,mBAAAH,iBAAA;gBACA,OAAAjD,KAAA,CAAAqD,cAAA;;cAEA,KAAAC,UAAA,OAAAF,uBAAA,mBAAAH,iBAAA;gBACA,OAAAjD,KAAA,CAAAuD,cAAA;cACA;YACA;cACA,KAAAJ,UAAA,QAAAE,cAAA;;;UAGA;;UAEA;;AAEA;AACA;AACA;;;;UAKA;;UAEA;;AAEA;AACA;AACA;;UAGAN,UAAA,CAAAtK,SAAA,CAAA+K,OAAA,YAAAA,QAAAtK,GAAA;;;;UAIA;AACA;AACA;AACA;AACA;AACA;;UAGA6J,UAAA,CAAAtK,SAAA,CAAA4K,cAAA,YAAAA,eAAA;YACA,IAAAI,KAAA,QAAAF,cAAA;YACA,IAAAE,KAAA,EAAgB;cAChB,KAAA1J,MAAA,QAAAA,MAAA,CAAAmI,KAAA,CAAAuB,KAAA,CAAAnI,MAAA;;;UAGA;;UAEA;AACA;AACA;;AAEA;;UAGAyH,UAAA,CAActK,SAAA,CAAA8K,cAAA,YAAAA,eAAA;YACd,SAAAnE,IAAA,IAAAsD,MAAA;cACA,IAAAA,MAAA,CAAAhK,cAAA,CAAA0G,IAAA;gBACA,IAAAsD,MAAA,CAAAtD,IAAA,EAAAhD,IAAA,MAAArC,MAAA;kBACA,IAAA0J,KAAA,GAAAC,aAAA,CAAAtE,IAAA,OAAArF,MAAA;kBAEA,IAAA0J,KAAA;oBACA,IAAAA,KAAA,CAAArE,IAAA,mCAAAhD,IAAA,CAAAqH,KAAA,CAAAxE,OAAA;sBACA;;sBAEAwE,KAAA,CAAAE,IAAA,QAAA5J,MAAA,CAAAyC,MAAA,IAAAiH,KAAA,CAAAnI,MAAA;sBACA,OAAAmI,KAAA;oBACA;kBACA;gBACA;cACA;YACA;;;UAGA;AACA;AACA;;AAEA;AACA;AACA;;UAGAV,UAAA,CAAAtK,SAAgB,CAAAmL,SAAA,YAAAA,UAAA;YAChB,YAAAN,UAAA;;;UAGA;AACA;AACA;;AAEA;AACA;AACA;;;;UAKA;;UAEA;AACA;AACA;AACA;AACA;;;YAIA,IAAAtK,GAAA;YACA,OAAAA,GAAA,QAAAgF,SAAA;cACA;cACA,IAAA6F,QAAgB,CAAA7K,GAAO,CAAAoG,IAAA,KAAAyE,QAAA,CAAA7K,GAAA,CAAAoG,IAAA,EAAApG,GAAA;gBACvB;;;UAGA;;UAEA;AACA;AACA;;AAEA;;UAGA+J,UAAA,CAAAtK,SAAuB,CAAAyH,KAAA,YAAAA,MAAA;YACvB,IAAA4D,IAAA,QAAA/J,MAAA;;;UAGA;;UAEA;;AAEA;AACA;;;;YAKA,YAAAA,MAAA;UACA;;QAGA;;QAKAgJ,UAAA,CAAAgB,aAAA,aAAA/K,GAAA;UACA,OAAAA,GAAA,CAAAgL,QAAA;QACA;QAEAjB,UAAA,CAAAkB,gBAAA,aAAAjF,KAAA;UACA,IAAAkF,YAAA;UAEA,SAAA3J,IAAA,IAAAyE,KAAA;;cAEAkF,YAAA,CAAA3J,IAAA,QAAApC,MAAA,CAAAgM,YAAA,EAAAnF,KAAA,CAAAzE,IAAA;YACA;UACA;UAEA,OAAA2J,YAAA;;QAGAnB,UAAA,CAAAG,QAAA,GAAAA,QAAA;;UAGA,IAAAA,QAAA,CAAAxK,cAAA,CAAAH,GAAA;;UAEA;QACA;;;SAGA;;QAGA;;QAEAf,OAAA,CAAAa,UAAA;QACA,IAAE+L,OAAA;QACF,IAAAC,SAAA;;QAIA;UACA,IAAAhK,IAAA;UACEiK,IAAA,CAAA7F,SAAA,GAAApE,IAAA;UACF7C,OAAA,CAAA4M,OAAA,GAAAA,OAAA,GAAAE,IAAA,CAAA7F,SAAA,KAAApE,IAAA;QACA,SAAAhB,CAAA;;QAEA;QAEA;UACAiL,IAAA,CAAA7F,SAAA;;QAEA,SAAOpF,CAAA;UACP7B,OAAA,CAAA6M,SAAA,GAAAA,SAAA;QACA;QAEAC,IAAA;QAEA9M,OAAA,CAAA4M,OAAA,GAAAA,OAAA;;;;SAIA;MACA,eAAA7M,MAAA,EAAAC,OAAA,EAAAK,mBAAA;QAEA;;;;;;;;QAMAL,OAAA,CAAAmL,OAAA,GAAAA,OAAA;QACAnL,OAAA,CAAAsL,KAAA,GAAAA,KAAA;QACAtL,OAAA,CAAAqL,QAAW,GAAAA,QAAA;QACXrL,OAAA,CAAA+M,SAAA,GAAAA,SAAA;QACA/M,OAAA,CAAAoL,MAAA,GAAAA,MAAA;QAEA,IAAA4B,OAAA,GAAA3M,mBAAA;;QAEA;AACA;;AAEA;AACA;QACA,IAAA4M,OAAA;UACA5B,QAAA,EAAY,+FAAO;UACnBD,MAAA,+BAAc;UACd5F,IAAA;UACA0H,QAAA;QACA;;QAEA;AACA;AACA;;AAEA;AACA;QACA,SAAA/B,QAAA5I,MAAA;UACA,IAAA4K,KAAY,GAAA5K,MAAO,CAAA6K,OAAA;UACnB,IAAAD,KAAA,IAAc;YACd,WAAAH,OAAA,CAAAK,YAAA,CAAA9K,MAAA,CAAAyC,MAAA,IAAAmI,KAAA,OAAAA,KAAA;UACA;QACA;;QAEA;;AAEA;AACA;AACA;AACA;QACA,SAAA7B,KAAcA,CAAA/I,MAAA;UACd,IAAA4K,KAAA,GAAA5K,MAAA,CAAA6K,OAAA;UACA,WAAAJ,OAAA,CAAAM,UAAA,CAAAH,KAAA,QAAAA,KAAA,GAAA5K,MAAA,CAAAuB,MAAA;QACA;;QAEA;AACA;AACA;AACA;AACA;AACA;;UAEA,IAAAyJ,WAAA,GAAAhL,MAAA,CAAA6K,OAAA;UACA,IAAAG,WAAA;YACA,IAAAC,KAAA,GAAAjL,MAAA,CAAAiL,KAAA,CAAAP,OAAA,CAAA5B,QAAA;YACA,IAAAmC,KAAY;cACZ,IAAAC,IAAA;gBACA,IAAAjG,KAAA;gBACA,IAAYkG,YAAA;gBACZ,IAAApB,IAAA,GAAAkB,KAAA;;kBAGA,MAAA3J,SAAA,OAAAA,SAAA,OAAAA,SAAA,OAAAA,SAAA;oBACU2D,KAAA,CAAAzE,IAAA;;oBAEVyE,KAAA,CAAA3D,SAAA;oBACA6J,YAAA,CAAA7J,SAAA;kBACA;oBACQ2D,KAAA,CAAAzE,IAAA,IAAAc,SAAA,OAAAA,SAAA,OAAAA,SAAA,OAAAoJ,OAAA,CAAAC,QAAA,CAAAtI,IAAA,CAAA7B,IAAA,KAAAA,IAAA;;kBAGRuJ,IAAA,GAAAA,IAAA,CAAA5E,OAAA,CAAA8F,KAAA;gBACA;;kBAGAG,CAAA,MAAAX,OAAA,CAAAY,aAAA,CAAAJ,KAAA,KAAAA,KAAA,IAAA1J,MAAA,EAAA0D,KAAA,EAAAkG,YAAA,IAAAF,KAAA,KAAAlB,IAAA,CAAA5E,OAAA;gBACA;cACA;cAEA,YAAc+F,IAAA,iCAAAI,OAAA,CAAAJ,IAAA,wBAAAA,IAAA,CAAAE,CAAA;YACd;UACA;QACA;;QAEA;AACA;AACA;AACA;AACA;AACA;QACA,SAAAZ,UAAAxK,MAAA;UACA,IAAAuL,KAAA,GAAAzC,QAAA,CAAA9I,MAAA;UACA,IAAAuL,KAAA;YACA,IAAAxB,IAAA,GAAA/J,MAAA,CAAAmI,KAAA,CAAAoD,KAAA,CAAAhK,MAAA;YACA;;cAEA;cACA,IAAA0J,KAAA,GAAAlB,IAAA,CAAAkB,KAAA,KAAAO,MAAA,yBAAAD,KAAA,CAAArG,OAAA;cACA,IAAA+F,KAAA;gBACA,OAAY,IAAOR,OAAA,CAAAgB,cAAA,CAAAF,KAAA,CAAArG,OAAA,EAAA+F,KAAA,IAAA1J,MAAA,GAAAgK,KAAA,CAAAhK,MAAA,EAAAgK,KAAA,CAAAtG,KAAA,EAAAsG,KAAA,CAAAJ,YAAA,EAAAF,KAAA;cACnB;YACA;UACA;QACA;;QAEA;AACA;AACA;;AAEA;AACA;QACA,SAAApC,OAAA7I,MAAA;;UAEA,IAAAiL,KAAA;;UAEA;QACA;;QAEA;MAAA,G;MAEA,eAAAzN,MAAA,EAAAC,OAAA,EAAAK,mBAAkD;QAElD;;QAEAL,OAAA,CAAAa,UAAA;QACAb,OAAA,CAAAiO,WAAA,GAAAjO,OAAA,CAAAgO,cAAA,GAAAhO,OAAA,CAAA4N,aAAA,GAAA5N,OAAA,CAAAkO,QAAA,GAAAlO,OAAA,CAAAsN,UAAA,GAAAtN,OAAA,CAAAqN,YAAA,GAAArN,OAAA,CAAAmO,KAAA,GAAAzL,SAAA;QAEA,IAAA/B,MAAA,GAAAN,mBAAA;QAEA,SAAAuF,gBAAAmF,QAAA,EAAAC,WAAA;UAAA,MAAAD,QAAA,YAAAC,WAAA;YAAA,UAAAC,SAAA;UAAA;QAAA;;QAEA;AACA;AACA;AACA;;QAEA;AACA;AACA;AACA;;AAEA;QACAjL,OAAA,CAAAmO,KAAA,YAAAA,MAAAvG,IAAA,EAAA9D,MAAA;UACA8B,eAAA,OAAAuI,KAAA;;UAGA,KAAArK,MAAA,GAAAA,MAAA;UACA,KAAAqI,IAAA;QACA;;QAEA;AACA;AACA;;;UAIA;AACA;AACA;AACA;AACA;;UAEA,SAAAkB,aAAAjE,OAAA,EAAAtF,MAAA;YACA8B,eAAA,OAAAyH,YAAA;;YAGA,KAAAvJ,MAAA,GAAAA,MAAA,KAAAsF,OAAA,GAAAA,OAAA,CAAAtF,MAAA;YACE,KAAAqI,IAAA;;UAEF;UAEAkB,YAAA,CAAApM,SAAA,CAAAuL,QAAA,YAAAA,SAAA;;;UAIA,OAAAa,YAAA;QACA;;QAEA;AACA;AACA;;QAGA,IAAAC,UAAA,GAAAtN,OAAA,CAAAsN,UAAA;UACA;AACA;AACA;;AAEA;UACA,SAAAA,WAAAxJ,MAAA;YACA8B,eAAA,OAAA0H,UAAA;YAEA,KAAA1F,IAAA;YACE,KAAA9D,MAAA,GAAAA,MAAA;;UAEF;UAEAwJ,UAAA,CAAArM,SAAA,CAAAuL,QAAA,YAAAA,SAAA;;;UAIA,OAAAc,UAAA;QACA;;QAEA;AACA;AACA;;QAGA,IAAAY,QAAA,GAAAlO,OAAA,CAAAkO,QAAA;UACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;UACA,SAAAA,SAAAtG,IAAA,EAAAH,OAAA,EAAA3D,MAAA,EAAA0D,KAAA,EAAAkG,YAAA;YACA9H,eAAA,OAAAsI,QAAA;;YAGA,KAAApK,MAAA,GAAAA,MAAA;YACA,KAAAqI,IAAA;YACA,KAAA1E,OAAA,GAAAA,OAAA;YACA,KAAAD,KAAc,GAAAA,KAAS;YACvB,KAAAkG,YAAsB,GAAAA,YAAA;YACtB,KAAA7F,KAAA,GAAgB,KAAO;YACvB,KAAAuG,UAAA;;;UAGA;AACA;;AAEA;AACA;AACA;AACA;;UAGAF,QAAA,CAAAG,SAAA,YAAAA,UAAA7M,GAAA;YACA,IAAA4H,OAAA,GAAAvF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAnB,SAAA,GAAAmB,SAAA;YAEA,IAAAnC,GAAA,SAAAF,GAAA,CAAAiG,OAAA;YACA,SAAA1G,GAAA,IAAAS,GAAA,CAAAgG,KAAA;;gBAEA9F,GAAA,UAAAX,GAAA;gBAEA,IAAAuN,GAAA,GAAA9M,GAAA,CAAAgG,KAAA,CAAAzG,GAAA;;kBAEAW,GAAA,eAAAf,MAAA,CAAAgM,YAAA,EAAA2B,GAAA;gBACA;cACM;YACN;;cAGA5M,GAAA,UAAAF,GAAA,CAAA8K,IAAA;YACA;;cAGA5K,GAAA;YACA;;YAEA;;cAGAA,GAAA,IAAA0H,OAAA,UAAA5H,GAAA,CAAAiG,OAAA;YACA;;;UAKA,OAAAyG,QAAA;QACA;;QAEA;AACA;AACA;;QAGA,IAAAN,aAAc,GAAA5N,OAAQ,CAAA4N,aAAA;UACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;UACA,SAAAA,cAAAnG,OAAA,EAAA3D,MAAA,EAAA0D,KAAA,EAAAkG,YAAA,EAAA7F,KAAA,EAAAyE,IAAA;YACA1G,eAAA,OAAAgI,aAAA;YAEA,KAAAhG,IAAA;;YAEA,KAAAuE,IAAA;YACA,KAAA1E,OAAA,GAAAA,OAAA;YACA,KAAAD,KAAA,GAAAA,KAAA;;YAEA,KAAA4G,UAAA;YACE,KAAAvG,KAAA,GAAAA,KAAA;;UAEF;UAEA+F,aAAA,CAAA3M,SAAA,CAAAuL,QAAA,YAAAA,SAAA;;;UAIA,OAAAoB,aAAA;QACA;;QAEA;AACA;AACA;;QAGA,IAAAI,cAAc,GAAOhO,OAAA,CAAAgO,cAAA;UACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;UACA,SAAAA,eAAAvG,OAAA,EAAA3D,MAAA,EAAA0D,KAAA,EAAAkG,YAAA,EAAAtE,OAAA;YACAxD,eAAA,OAAAoI,cAAA;YAEA,KAAApG,IAAA;;YAEA,KAAAuE,IAAA;YACA,KAAA1E,OAAA,GAAAA,OAAA;YACA,KAAAD,KAAA,GAAAA,KAAA;;YAEA,KAAAK,KAAA;YACE,KAAAuG,UAAA;;UAEF;UAEAJ,cAAA,CAAA/M,SAAA,CAAAuL,QAAA,YAAAA,SAAA;;;UAIA,OAAAwB,cAAA;QACA;;QAEA;AACA;AACA;;;UAIA;AACA;AACA;AACA;AACA;;UAEA,SAAAC,YAAAxG,OAAA,EAAA3D,MAAA;YACA8B,eAAA,OAAAqI,WAAA;;YAGA,KAAAnK,MAAA,GAAAA,MAAA;YACE,KAAAqI,IAAA;;UAEF;UAEA8B,WAAA,CAAAhN,SAAA,CAAAuL,QAAA,YAAAA,SAAA;;UAEA;UAEA,OAAAyB,WAAA;QACA;;QAEA;MAAA,GACA;MACA,eAAAlO,MAAA,EAAAC,OAAA;QAEA,YAAY;;QAEZA,OAAA,CAAAa,UAAA;QACAb,OAAA,CAAA2M,YAAA,GAAAA,YAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;QACA,SAAAA,aAAApH,KAAA;;;UAGA;UACA;;YAEA,YAAAX,IAAA,CAAA2J,MAAA,IAAAA,MAAA,SAAAA,MAAA;UAEA;QACA;;QAEA;MAAA,GACA;MACA,eAAWxO,MAAA,EAAAC,OAAA;QAEX;;QAEAA,OAAA,CAAAa,UAAA;QACAb,OAAA,cAAAwO,qBAAA;QACA;AACA;AACA;AACA;;QAEA,IAAAC,KAAA;;QAEA;AACA;AACA;AACA;AACA;QACA,IAAAC,SAAA;;QAEA;AACA;AACA;AACA;;AAEA;QACA,SAAAC,QAAAnN,GAAA;UACA,IAAAA,GAAA,IAAAA,GAAA,CAAAoG,IAAA;YACApG,GAAA,CAAAqG,KAAY,GAAA4G,KAAA,CAAW7J,IAAA,CAAApD,GAAA,CAAAiG,OAAA,KAAAjG,GAAA,CAAAqG,KAAA;YACvBrG,GAAA,CAAA4M,UAAY,GAAS,QAAAxJ,IAAA,CAAApD,GAAA,CAAA2K,IAAA;UACrB;UACA,OAAA3K,GAAA;QACA;;QAEA;AACA;AACA;AACA;;AAEA;AACA;QACA,SAAA4K,UAAAzG,MAAA,EAAAiJ,aAAA;UACA,IAAAC,GAAA,GAAYlJ,MAAA,CAAApD,MAAW;UACvB,IAAAf,GAAA,GAAYmN,OAAA,CAAAC,aAAa;UACzBjJ,MAAA,CAAApD,MAAA,GAAAsM,GAAA;UACA,OAAArN,GAAA;QACA;;QAEA;AACA;AACA;;AAEA;AACA;QACA,SAAAsN,UAAAnJ,MAAA,EAAAoC,KAAA;UACA,IAAAvG,GAAA,GAAAuG,KAAc,CAAAgH,GAAA;;UAEd;UACApJ,MAAA,CAAAqG,OAAA,QAAAxK,GAAA,CAAAiG,OAAA;;;QAGA;AACA;;AAEA;AACA;QACA,SAAAuH,SAAA;UACA,IAAAjH,KAAA;UAEAA,KAAA,CAAA1F,IAAA;YACA,iBAAAyB,MAAyB;UACzB;UAEAiE,KAAA,CAAAkH,aAAA,aAAAxH,OAAA;YACA,IAAApF,IAAA,QAAAA,IAAA;YACA,OAAAA,IAAA,IAAAA,IAAA,CAAAoF,OAAA,IAAApF,IAAA,CAAAoF,OAAA,CAAAyH,WAAA,OAAAzH,OAAA,CAAAyH,WAAA;UACA;UAEAnH,KAAA,CAAAoH,eAAA,aAAA1H,OAAA;YACA,SAAAH,CAAA,MAAA9F,GAAA,EAAAA,GAAA,QAAA8F,CAAA,GAAAA,CAAA;;gBAEA;cACA;YACA;YACA,OAAY;UACZ;UAEA,OAAAS,KAAY;QACZ;;QAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;QACA,SAAAyG,sBAAA7I,MAAA,EAAAvD,OAAA,EAAAwM,aAAA;UACA,IAAA7G,KAAQ,GAAAiH,QAAA;UAER,IAAA3C,QAAA;YACAhB,QAAU,WAAAA,SAAA7J,GAAA;cACV,IAAAiG,OAAA,GAAAjG,GAAA,CAAAiG,OAAA;cAEA,IAAAA,OAAA,CAAAyH,WAAA,eAAAnH,KAAA,CAAAkH,aAAA;gBACQtJ,MAAA,CAAAqG,OAAA;gBACRoD,gBAAA;cACA,WAAAhN,OAAA,CAAAiN,YAAA,IAAAX,SAAA,CAAA9J,IAAA,CAAA6C,OAAA,KAAAM,KAAA,CAAAoH,eAAA,CAAA1H,OAAA;gBACM,IAAAM,KAAA,CAAAkH,aAAA,CAAAxH,OAAA;kBACNqH,SAAA,CAAAnJ,MAAA,EAAAoC,KAAA;gBACA;kBACApC,MAAA,CAAAqG,OAAA,QAAAxK,GAAA,CAAAiG,OAAA;kBACA2H,gBAAA;gBACA;cACA,YAAA5N,GAAA,CAAAqG,KAAA;gBACAE,KAAU,CAAA5C,IAAA,CAAA3D,GAAA;cACV;YACA;YACA4J,MAAQ,WAAAA,OAAA5J,GAAA;cACR,IAAAa,IAAA,GAAA0F,KAAA,CAAA1F,IAAA;cACA,IAAAA,IAAA;gBACA,IAAAD,OAAA,CAAAkN,UAAA,KAAAvH,KAAA,CAAAkH,aAAA,CAAAzN,GAAA,CAAAiG,OAAA;kBACA;kBACAqH,SAAA,CAAAnJ,MAAA,EAAAoC,KAAA;gBACA;;gBAEA;cACA,WAAA3F,OAAA,CAAAkN,UAAA;gBACA;gBACAV,aAAA;gBACAQ,gBAAA;cACA;;UAEA;UAEA,SAAAA,iBAAA;YACA,IAAA5N,GAAA,GAAA4K,SAAA,CAAAzG,MAAA,EAAAiJ,aAAA;YACA,IAAApN,GAAA,IAAA6K,QAAA,CAAA7K,GAAA,CAAAoG,IAAA;;YAEA;UACA;;;;;;;;;;;;;;;iBCl5BgB7H,M,EAAAC,OAAA,E;gBA0BA;;YA+BAa,UAAA,O;eA6BA,G;;;;;YAsBAmH,MAAA,G,MAAA;IA5HhBhI,OAAA,CAAA0E,UAAA,GAAAA,UAAA;;;;;;IAMO1E,OAAA,CAAAuP,KAAS,GAAOA,KAAhB;IACLvP,OAAA,CAAAyG,QAAO,GAAUA,QAAV;IACRzG,OAAA,CAAA0G,OAAA,GAAAA,OAAA;;AAED;;;;;;MAMO,OAAS8I,KAAA,KAAT,KAAuB,KAAAA,KAAA;IAC5B;;;AAGF;;;;;;;IAOO;;IAEL;AACA;AACE;AACD;AACF;;AAED;;;;;;;IAOO;;IAEH;AACE;AACD;AACF;AACF;;AAED;;;;;;;IAOO;;IAEL;AACE;AACE;AACD;AACF;AACD;AACD;;MAEDpN,OAAA,GAAAA,OAAA;;;;;;MAMO,OAASA,OAAT;IACL;;IAEC;AAAW;AACV;AACA;AACE;AACD;IACD,SAAAqN,QAAA7O,GAAA;MAAA;QAAA,OAAAmD,KAAA,CAAA9C,SAAA,CAAAyJ,KAAA,CAAAvJ,IAAA,CAAAP,GAAA;MALU,SAAAiB,CAAA;;UAAA,IAAA6N,GAAA;UAMXC,IAAA,CAAA/O,GAAA,YAAA0N,GAAA;YACFoB,GAAA,CAAAvK,IAAA,CAAAmJ,GAAA;;UAED;;;;;MAMO;IACL;;;AAGF;;;;;;;IAOO;;IAIN;;AAED;;;;;;MAMO,OAAS,CAAA9M,GAAA,IAAT,EAAkBA,GAAlB,CAAuBoG,IAAA,mBAAApG,GAAA,CAAAoG,IAAA,oCAAApG,GAAA,YAAAA,GAAA,CAAAiG,OAAA,CAAAmI,WAAA,GAAAxC,OAAA,CAAAyC,GAAA;IAC5B;;;AAGF;;;;;;MAMO,OAASN,KAAA,CAAA/N,GAAQ,EAAjB,QAAsB;IAC3B","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}